;NABU System Monitor ver 3.0
;James Penner
;February 10, 2023
;
; Revisions
; 1.0 Workable Text UI interface
; 2.0 Added UI capability, Command Interpreter, and functions for (A) Address inspection/change, (D) Memory Dump
; 3.0 Added Cursor, (R) Reset, (O) Registers, (C) Copy & Paste RAM, and (?) help

;Adds/Fixes:
;- Cursor
;- Reset(R)
;- Registers(O) Operation
;- Check for command - Tune data entry for this
;- Action on command - Add Load, Save, Registers, Reset, Copy & Paste
;- Perform a RAM read test
;- Test my Video address Correction
;- Do we really need to check for stray characters?
;
;ROM Notes
;24pin ROM		Default NABU 4k ROM (eg 24pin 2732 Hitachi HN462732G)
;28pin ROM		Can be accomidated, but should be checked; (eg Winbond W27C512 and AMTEL 27C64B) - And are 4k limited without PCB mod
;4k/8k+ ROMs	NABU will only support on base architedture 2 memory sizes; 4k 24pin/28pin, and 8k 28pin
;				Using 28pin(8k) ROM will require a jumper change on the PCB from 4k to 8k usage. This jumper is located on the NABU PCB
;				in the upper right corner of the Z80 CPU. Cut the 4k trace and jump the 8k points
;				Using a only 4k of a 28pin ROM is ok without modifying the NABU PCB, however programatically they will need to be
;				addressed difffernetly when buring the ROM image.
;				- Using a 27C256 EPROM has required the positioning of the ROM image at 0x6000h.
;					Theory: This 28pin ROM has 16 address lines, NABU requires 12 (Schematic identifies 13 A0-A12)
;					Using 13, upper accessable addresses are ignored, so the ROM image should not be burned in this area.
;					By Reference, this is addressed to start at 0xE000h or (1110 0000 0000 0000) for a max EPROM 27C512
;				- Using a 28C64B EEPROM DOES NOT require the positioning of the ROM image other than 0000h.
;					Theory: This 28pin ROM has 16 address lines, NABU requires 12 (Schematic identifies 13 A0-A12)
;					Using 13, upper accessable addresses are ignored, so the ROM image should not be burned in this area.
;					By Reference, this is addressed to start at 0xE000h or (1110 0000 0000 0000)
;Checksum		The check sum is generated by adding all the bytes of the 4k ROM with the exception of the last two bytes. Then the two
;				least significant bytes become the check sum to be addded to the last two bytes of the ROM
;
;Written based on the understanding of the diasassembled ROM, Technical references and some work of others. This is considered open
;source for non-commercial use, unless granted by author. Some attributed and unattributed reference are from
; - Michael Davis www.mdpub.com - Baseline orgainizational framework and some routines
;
;Register use - General notes
;HL		Used for Relative program memory addressing, the VDP Text mode Table name address for video displayed, and other temporary use
;A		Used for Keyboard/Video character manipulation, temporary use
;B		Counters
;DE		Temorary values for math
;
;Addressing notes
; 0x0000-0x0FFFh		ROM
; 0x1000				RAM Start
; 0x4000h				Represents Video RAM address space of 16k
; 0x03C0h				In Text Mode, this is the Name Table space for a 40 x 24 character screen; 960
;
;The NABU system monitor is ROM based and has the following features:
;Physical
;- Confined to 40x24 screen
;- Monochrome
;- Line oriended operation
;
;Operational
;- DRAM scope for Read/Write
;- VRAM scope for Read only
;- ROM scope for Read only
;- Commands
;  - A Displays the current/last Address
;    - Prompt:		Addr?		aaaa
;    - Format:		aaaa:vv
;    - Feature:	Allows for the address (aaaa) value (vv) to be replaced
;    - Fucntion:	HEX decimal entry, Return for next line, Escape to breakout
;  - D Display DRAM
;    - Prompt:		Addr?		aaaa
;    - Format:		aaaa: vv vv vv vv vv vv vv vv  ........
;    - Feature:	Dumps 22 lines starting from address entered
;					Displays the address, 8 bytes in HEX, and the ASCII equivalent per row
;    - Fucntion:	Return for next page, Escape to breakout
;  - L Load
;    - Prompt:		Source? (1-Serial, 2-Floppy, 3-SD card)
;    - Prompt:		Destin? (Default=Source dictates, Address 0400h)
;    - Prompt:		Length? (tbd)
;  - S Save
;    - Prompt:		Destin? (1-Serial, 2-Floppy, 3-SD card, 4-Printer)
;    - Prompt:		Source? (Default=Source dictates, Address 0400h)
;    - Prompt:		Length? (tbd)
;  - C Copy RAM (& Paste)
;    - Prompt:		Source?		ssss
;    - Prompt:		Destin?		dddd
;    - Prompt:		Bytes?		bbbb
;    - Feature:	Allows the bytes (bbbb) to be copied from address (ssss) to Destination (dddd)
;    - Fucntion:	HEX decimal entry, Return to enter, Escape to breakout
;	- R Registers
;    - Function:	Display of Current Register settings
;                 A F   B C   D E   H L   I X   I Y
;                 31E5  03CA  0001  06E0  0000  0000
;					STATUS (F)  S  Z  X  H  X  PV N  C
;                             1  1  1  0  0  1  0  1
;  - ? Help
;    - Function:	Display summary lsit of these commands
;                 ?-Help			A-Address		D-Dump
;					L-Load			S-Save			C-Copy RAM
;					R-Registers	B-Reset			G-Go
;  - G Goto address and execute
;
;Organization
;- Initialize
;- Clear Screen
;- Display title
;  - Manage Characters
;    - Display Character or Action
;- Main loop
;  - Keyboard input, Video output
;  - Command processing
;    ?-Help					3.0
;    A-Address					2.0
;    D-Dump					2.0
;    L-Load
;    S-Save
;    C-Cut&Paste				3.0
;    O-Operation				3.0
;    R-Reset					3.0
;    G-Go						3.0
;----------------------------------------------------------------------------------------------------
;--- Declarations -----------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------

;jpenner - Allocate Stack and Program space: Stack from FFFF (and backwards), Program space from FE00 (and forward)
POS_X			.equ 0fe00h				;jpenner - Address to Store Text row Column position 0..39				FE01 Next
POS_Y			.equ 0fe01h				;jpenner - Address to store Text row position 0..23						FE02 Next
EOL_MARKER		.equ 0fe02h				;jpenner - Reserved for marking End Of Line; POS_X marker					FE03 Next
SOL_MARKER		.equ 0fe03h				;jpenner - Reserved for marking Start Of Line; Post prompt marker			FE04 Next
TEMP_ROW_ARRAY	.equ 0fe04h				;jpenner - Temporary row storage for screen scrolling (40 characters)	FE2C Next
BUFF_IN			.equ 0fe2ch				;jpenner - Buffer for entered line (20 characters)							FE40 Next
BUFF_OUT		.equ 0fe40h				;jpenner - Buffer for entered line (20 characters)							FE54 Next
ROW_MARKER		.equ 0fe54h				;jpenner - Row count Marker. Used with the B register						FE55 Next
REG_HOLD		.equ 0fe55h				;jpenner - Register hold for A and DE (Temporary)							FE58 Next
CNTRL_STATE		.equ 0fe59h				;jpenner - Control Register State value										FE5A Next
;jpenner - NOTE: Buffer, variable Stack space from FE5Ah to FFFFh
STACK_TOP		.equ 0000h				;jpenner - Top of Stack (SP); Push/Pop to decrement/Increment by 2 bytes; First Push at FFFEh

;jpenner - Special references
CHAR_MAP_SPACE	.equ 02d8h				;jpenner - 59 characters * 8 bytes/char = 472 or (01D8). Change if Character set map is built larger
PROMPT			.equ 3ah				;jpenner - Newline prompt ":"
FILL_CHAR		.equ 20h				;jpenner - Default is 20h (Space). Can be set to another ASCII char as a screen fill character for Screen Testing
CURSOR_CHAR		.equ 3eh				;jpenner - Cursor character. Default is ">"

;jpenner - Define NABU Architecture ports
CNTRL_REG:		.equ	00h 			;jpenner - Label for referencing the control register
SOUND_DATA:		.equ	40h  			;jpenner - Label for referencing the Sound data to be passed after the SOUND_LATCH is set
SOUND_LATCH:	.equ	41h  			;jpenner - Label for referencing the Sound Latch address
HCCA_IN_OUT:	.equ	80h 			;jpenner - Label for referencing the Serial communications in/out
KEYBD_DATA:		.equ	90h  			;jpenner - Label for referencing the Keyboard data to be sent/recevied
KEYBD_STATUS:	.equ	91h 			;jpenner - Label for referencing the Keyboard status
VIDEO_DATA:		.equ 	0a0h 			;jpenner - Label for referencing the VDP data to be sent
VIDEO_LATCH:	.equ	0a1h 			;jpenner - Label for referencing the VDP Latch address
PRINTER_OUT:    .equ 	0b0h 			;jpenner - Label for referencing the Printer output port

;jpenner - Option Card interface Base address
OPTC0_BASE:		.equ	0C0h			;jpenner - Option Card 0 Base address (C0-CF)
OPTC1_BASE:		.equ	0D0h			;jpenner - Option Card 1 Base address (D0-DF) 
OPTC2_BASE:		.equ	0E0h			;jpenner - Option Card 2 Base address (E0-EF)
OPTC3_BASE:		.equ	0F0h			;jpenner - Option Card 3 Base address (F0-FF)

				.org	0000h			;jpenner - Start position for this code
;----------------------------------------------------------------------------------------------------
;--- Main loop --------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------
START:
            di							;jpenner - Disable Interrupts
            ld sp,STACK_TOP				;jpenner - Set the Stack Pointer
			ld a,00h					;jpenner - Set defaults for Control Register reference state 0000 0000 = 00h
            ld (CNTRL_STATE),a			;jpenner - Control Register State
            call VIDEO_INIT				;jpenner - Initialize the video (Text), Clear VRAM (Name), & Store ASCII map (Pattern)
            call KEYBD_INIT				;jpenner - Initialize the keybord
			call SOUND_INIT				;jpenner - Initialize the sound
 			call ACT_BEL				;jpenner - Ring the bell
			xor a						;jpenner - Initialize A (Zero)
			ld (POS_X),a				;jpenner - Set the X character position to Column 0
			ld (POS_Y),a				;jpenner - Set the Y character position to Row 0
			ld (EOL_MARKER),a			;jpenner - Reset/Store EOL marker (Not EOL)
            ld hl,TITLE					;jpenner - Point to title message
            ld b,TITLE_END - TITLE		;jpenner - Set B to Lenght of title; Character supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display title
			ld a,PROMPT					;jpenner - Set the new line prompt
            call DISPLAY_CHAR			;jpenner - Output Prompt
			call ACT_BEL				;jpenner - Ring the bell. Ready to go...

MONITOR_LOOP:
;            ld (POS_X),a				;jpenner - Set current X Position
            ld a,(POS_X)				;jpenner - Get current X position
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
 			call GET_LINE				;jpenner - Wait for keyboard character, and return in Accumulator
			call CHECK_CMD				;jpenner - Check and Execute command
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld a,PROMPT					;jpenner - Set the new line prompt
            OUT (VIDEO_DATA),a			;jpenner - Output Prompt
            ld a,(POS_X)				;jpenner - Get current X position
            inc a						;jpenner - Increment X position
            ld (POS_X),a				;jpenner - Save X Position
            call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
            jp MONITOR_LOOP

;----------------------------------------------------------------------------------------------------
;--- Called functions -------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------
GET_HLINE:
;jpenner - GET_HLINE will get a line of HEX characters with the following features
;jpenner - 1) Every character is checked as a HEX digit (0..9,A..F). Bad character (bell)
;jpenner - 2) Escape (1Bh) will break the entry, ring bell and restart.
;jpenner - 3) X/Y and SOL/EOL are managed
;jpenner - 4) Values are saved in the BUFF_IN
;jpenner - Input: Number of HEX values to accept (A)
;jpenner - Output: BUFF_IN populated if completed entry
;jpenner - Output: Actual Hex value in A
;jpenner - Output: Escape status set in B to FF, B=FF, Abort/Escape
;jpenner - Output: Return status set in B to FE, B=FEh, No value returned
;jpenner - Output: X/Y and SOL/EOL are managed
			push de
			push hl
            ld de,BUFF_IN				;jpenner - Point to Line buffer           
			ld b,a						;jpenner - Set the number of HEX characters to accept
			ld a,(POS_X)
			ld (SOL_MARKER),a
			ld (EOL_MARKER),a
		
NEXT_HEX:	call KEYBD_GETCHAR			;jpenner - Wait for keyboard character, and return in Accumulator
			cp 1Bh						;jpenner - Is the key a Escape (1Bh)?
			jr z,GET_HLINE_BRK			;jpenner - Exit: Escape status set in B to FF B=FF, Abort/Escape
			cp 0Dh						;jpenner - Is the key a Return (0Dh)?
			jr z,GET_HLINE_ABORT		;jpenner - Next Addr: Return status set in B to FE, B=FEh, No value returned
									;jpenner - Check if HEX digit
			push bc						;jpenner - Save the character count to be entered
			ld hl,HEX_DIGIT				;jpenner - Point to HEX digits
			ld b,10h					;jpenner - Set counter to 16 characters
NEXT_DIG:	ld c,(hl)					;jpenner - Get HEX digit
			cp c						;jpenner - Compare HEX digit to Entered in Key
			jr z,HEX_FOUND				;jpenner - Found!
			inc hl						;jpenner - Point to next HEX character
			djnz NEXT_DIG				;jpenner - Continue search if not found
			jr HEX_NFOUND
HEX_FOUND:	pop bc						;jpenner - Restore the character count to be entered
			jp HEX_STORE				;jpenner - If not, Store and display character
HEX_NFOUND:	pop bc
			call ACT_BEL				;jpenner - Bad character, Ring the bell
			jr NEXT_HEX					;jpenner - Try Again!
HEX_STORE:
			ld (de),a					;jpenner - Save the character
			inc de						;jpenner - Point to next character spot in buffer
			call DISPLAY_CHAR			;jpenner - Display character and/or Drive keyboard action
			djnz NEXT_HEX
			ld hl,BUFF_IN				;jpenner - Point to Buffer
			ld d,(hl)
			inc hl
			ld e,(hl)
			call HEX2NUM				;jpenner - Returns the actual number 00..FF in A
			ld b,00h					;jpenner - Set Status to 00h on the way back (00=OK)
			jr GET_HLINE_END			;jpenner - Jump to end
GET_HLINE_BRK:
			ld b,0ffh					;jpenner - Return status back (FFh) - Escape (1Bh)
			call ACT_BEL
			jr GET_HLINE_END
GET_HLINE_ABORT:
			ld b,0feh					;jpenner - Return status back (FEh) - Return (0Dh)
GET_HLINE_END:
			push af						;jpenner - Preserve returned value in A (Output: B is status, A is value)
			ld a,28h					;jpenner - Point to end of Row
			ld (POS_X),a				;jpenner - Trigger an VDP EOL
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			pop af						;jpenner - Return A value
			pop hl
			pop de
			ret

GET_LINE:
NEXT_CHAR:	call KEYBD_GETCHAR			;jpenner - Wait for keyboard character, and return in Accumulator
			call DISPLAY_CHAR			;jpenner - Display character and/or Drive keyboard action
			ld a,(EOL_MARKER)			;jpenner - Check for EOL
			cp 00h						;jpenner - Was an EOL recorded?
			jr z,NEXT_CHAR				;jpenner - When 0, EOL is not recorded; Get another char
GET_LINE_DONE:
			ld a,00h					;jpenner - Reset EOL marker to 0
			ld (EOL_MARKER),a			;jpenner - Store EOL marker (Preperation for next GET_LINE call
			ret
GET_LINE_END:

KEYBD_GETCHAR:
            in a,(KEYBD_STATUS)			;jpenner - Get status word from USART (Keyboard)
            bit 1,a 					;jpenner - Check for bit 1 (RxRDY) for received character
            jr z,KEYBD_GETCHAR			;jpenner - Continue to scan until bit 1 (RxRDY) is set [......1.]
            in a,(KEYBD_DATA)			;jpenner - Receive Keyboard character
			cp 094h						;jpenner - Check for keyboard status pulse (watchdog pulse)
			jr z,KEYBD_GETCHAR			;jpenner - Scan again
            ret							;jpenner - Else return with Keyboard character in A/Accumulator

MSG_DISPLAY:						;jpenner - hl=Message address pointer, b=character count
MSG_LOOP:	ld a,(hl)					;jpenner - Get character of message
            call DISPLAY_CHAR			;jpenner - Put character on screen
            inc hl						;jpenner - Point to next character address
            nop							;jpenner - Supports a 4 clock cycle wait for VDP to catch up
            nop							;jpenner - Supports a 4 clock cycle wait for VDP to catch up
            djnz MSG_LOOP				;jpenner - Repeat until all characters are displayed
            ret

DISPLAY_CHAR:					;jpenner - Manage Character display/funtion
DSP_NABU:							;jpenner - NABU Printable 20h-5Ah
			push af
			scf
			sbc a,1fh					;jpenner - (31+c=32) If carry set, implies Charater is in range of 00-1F; non-printable
			jp c,DSP_ACTION				;jpenner - Treat as an Actionable character
			scf
			sbc a,3ah					;jpenner - (58+c=59) Pull value down more...If No carry set, implies Charater is beyond NABU Printable characters in range of 5B-FF; A-20h-3Bh.....Other printable
			jp nc,DSP_OTHER				;jpenner - Treat as an other extended character
			pop af						;jpenner - Restore actual value
			call DSP_CHAR				;jpenner - Display printable character
			jp DSP_EXIT
DSP_ACTION:							;jpenner - Actionable 00h-1F & 7F (ASCII)
			pop af						;jpenner - Restore actual value
			cp 00h						;jpenner - Check if NUL (String termination) used for Text Message displays; Stop, no CR, no Prompt
			jp z,DSP_EXIT				;jpenner - Action the End Of Text (Stop, no CR, no Prompt)
			cp 04h						;jpenner - Check if EOT (End Of Text) used for Text Message displays; CR without the Data Entry Prompt
			jp z,ACT_EOT				;jpenner - Action the End Of Text (CR without Prompt)
			cp 0dh						;jpenner - Check if CR (GO)
			jp z,ACT_CR					;jpenner - Action the Carrage Return (CR with Prompt)
			cp 08h						;jpenner - Check if BS (DEL/<-)
			jp z,ACT_DEL				;jpenner - Action the Backspace
			cp 07h						;jpenner - Check if BEL
			jp z,ACT_BEL				;jpenner - Action the Bell
;---			cp 1Bh						;jpenner - Check if ESC
;---			jp z,DSP_ESC				;jpenner - Action the Escape
			jp DSP_EXIT
DSP_OTHER:							;jpenner - Other Printable or NABU Keys 5Bh-7Eh (only if Character mapped)
			pop af						;jpenner - Restore actual value
			cp 7fh						;jpenner - Check if DELETE key (DEL = 7Fh) (<-/BS)
			jp z,ACT_DEL				;jpenner - Treat as an Actionable character
			cp 0e1h						;jpenner - Check if <- key (<- = E1h) (BS/DEL)
			jp z,ACT_DEL				;jpenner - Action the Backspace
			cp 0e5h						;jpenner - Check if <||| key (<||| = E5h) (DEL to begining of line)
			jp z,ACT_DEL_ALL			;jpenner - Action the DEL to begining of line
			cp 0e7h						;jpenner - Check if YES (CR/Enter/GO)
			jp z,ACT_CR					;jpenner - Action the Carrage Return
;			call ACT_BEL				;jpenner - Not valid at this time
			jp DSP_EXIT
DSP_EXIT:
			ret

DSP_CHAR:
			out (VIDEO_DATA),a			;jpenner - Output Character
            ld a,(POS_X)				;jpenner - Get current X position
            inc a						;jpenner - Increment X position
            ld (POS_X),a				;jpenner - Save X Position
			call POS_CURSOR				;jpenner - Address screen wrapping
			ret

ACT_DEL:								;Unnecessary portion can be removed as Backspace will never reach upper left corner of screen (0,0)
;			ld a,(POS_Y)				;jpenner - Unnecessary - Get current Y
;			dec a						;jpenner - Unnecessary - Check <0
;			jp nc,DEL_SKIP1			;jpenner - Unnecessary - Skip if not Row 0
;			ld a,(POS_X)				;jpenner - Unnecessary - Get current X
;			dec a						;jpenner - Unnecessary - Check <0
;			jp nz,DEL_SKIP1			;jpenner - Unnecessary - Skip if not Column 0
;			call ACT_BEL				;jpenner - Unnecessary - Ring bell, cannot back up
;			jp DEL_END					;jpenner - Unnecessary - exit routine
DEL_SKIP1:	ld a,(POS_X)				;jpenner - Get current X 
            dec a						;jpenner - Increment X position
			jp nz,DEL_SKIP2				;jpenner - Skip if not Column 0
			call ACT_BEL				;jpenner - Ring bell, cannot back up
			jp DEL_END					;jpenner - exit routine
DEL_SKIP2:  ld (POS_X),a				;jpenner - Save X Position
            call POS_CURSOR				;jpenner - Address screen wrapping
			ld a,20h					;jpenner - Get ready to blank the position
            out (VIDEO_DATA),a			;jpenner - Output Character
            call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
DEL_END:	ret

ACT_DEL_ALL:
			ld a,(POS_X)				;jpenner - Get cursor position
			ld b,a						;jpenner - Save as backspace count
			dec b						;jpenner - Decrement by 1
			jr z,DEL_ALL_END			;jpenner - End if a blank line
DEL_CHAR:
			call ACT_DEL				;jpenner - Del last character
			djnz DEL_CHAR				;jpenner - Repeat until row is cleared
DEL_ALL_END:
			ret

ACT_EOT:
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ret
ACT_EOT_END:

ACT_CR:
			ld a,(POS_X)				;jpenner - Get current column where CR is entered
			ld (EOL_MARKER),a			;jpenner - Mark as End Of Line
			call BUFFER_LINE			;jpenner - Buffer line
			ret
ACT_CR_END:

BUFFER_LINE:						;jpenner - Buffer line after a CR
            ld de,BUFF_IN				;jpenner - Point to Line buffer           
			ld a,(SOL_MARKER)			;jpenner - Get the Start of Line
			ld b,a						;jpenner - Save in b
			ld a,(EOL_MARKER)			;jpenner - Get End of Line position
			sub b						;jpenner - Determine Line length
			jr nz,BUFFER_START			;jpenner - Skip if there is something to buffer
			ld (EOL_MARKER),a			;jpenner - Reset the EOL to line length to 0
			jp BUFFER_END				;jpenner - Nothing to buffer...
BUFFER_START:
			ld b,a						;jpenner - Set actual the Character count
			ld a,(SOL_MARKER)			;jpenner - Get the Start of Line
			ld (POS_X),a				;jpenner - Set to start of Line
            call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			in a,(VIDEO_DATA)			;jpenner - Flush input buffer from previous VDP location
BUFFER_LOOP:
			in a,(VIDEO_DATA)			;jpenner - Get the current character
            ld (de),a					;jpenner - Store row character in Temp buffer
            inc de						;jpenner - Point to next Temp buffer location for next character storage
            djnz BUFFER_LOOP			;jpenner - Repeat until line is buffered by count in B
BUFFER_END:	ld a,04h					;jpenner - Store EOT character for string termination
            ld (de),a					;jpenner - Store row character in Temp buffer
			ld a,01h					;jpenner - Set a to SOL
			ld (SOL_MARKER),a			;jpenner - Reset the SOL to 1. EOL is reset at the begining with B
;			call BUFF_DISPLAY
			ret
BUFFER_LINE_END:

BUFF_DISPLAY:						;jpenner - Debug routine to check the Buffer
			ld a,28h					;jpenner - Trigger new line on screen
			ld (POS_X),a				;jpenner - Set to start of Line
            call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
            ld hl,BUFF_IN				;jpenner - Point to Line Buffer            
			ld b,04h					;jpenner - Set to display 4 characters
BUFF_LOOP:
			ld a,(HL)					;jpenner - Get the buffer character
			out (VIDEO_DATA),a			;jpenner - Display the character
			inc hl						;jpenner - Point to next buffer character position
			djnz BUFF_LOOP				;jpenner - Repeat
			ret
BUFF_DISPLAY_END:

CHECK_CMD:
            ld de,BUFF_IN				;jpenner - Point to Line buffer            
			ld a,(SOL_MARKER)			;jpenner - Get the Start of Line
			ld b,a						;jpenner - Save in b
			ld a,(EOL_MARKER)			;jpenner - Get End of Line position
			sub b						;jpenner - Determine Line length
			jr nz,CHECK_START			;jpenner - Skip if there is something to buffer
			ld (EOL_MARKER),a			;jpenner - Reset the EOL to line length to 0
			jp CHECK_CMD_END			;jpenner - Nothing to buffer...
CHECK_START:
			ld b,a						;jpenner - Set actual the Character count
			ld a,(SOL_MARKER)			;jpenner - Get the Start of Line
			ld (POS_X),a				;jpenner - Set to start of Line
            call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
CHECK_LOOP:
			ld a,(de)					;jpenner - Get Buffer character
			cp 20h						;jpenner - End of word?
			jr z,CHECK_DONE				;jpenner - Terminate for now..Intended for word parsing..
CHECK_A:	cp "A"						;jpenner - "A" Entered?
			jr nz,CHECK_D				;jpenner - If not, Check D
			CALL ADDR_ENT				;jpenner - ADDRESS: Get address, display, and edit
			ld a,00h					;jpenner - Reset EOL to 00h
			ld (EOL_MARKER),a			;jpenner - Reset the EOL to line length to 0
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_D:	cp "D"						;jpenner - "D" Entered?
			jr nz,CHECK_R				;jpenner - If not, Check O
			CALL DUMP_DAT				;jpenner - DUMP: Get address and display
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_R:	cp "R"						;jpenner - "R" Entered?
			jr nz,CHECK_B				;jpenner - If not, Check B
			call OPER_REG				;jpenner - REGISTERS: Show Registers & Other stats
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_B:	cp "B"						;jpenner - "B" Entered?
			jr nz,CHECK_C				;jpenner - If not, Check C
			jp 0000h					;**jpenner - BOOT: Drop all of this and Boot/Restart over consideration to reset SP
;			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_C:	cp "C"						;jpenner - "C" Entered?
			jr nz,CHECK_Q				;jpenner - If not, Check Q
			CALL COPY_PST				;jpenner - LOAD: Load from Source to RAM
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_Q:	cp "?"						;jpenner - "?" Entered?
			jr nz,CHECK_G				;jpenner - If not, Check G
			CALL HELP_TXT				;jpenner - LOAD: Load from Source to RAM
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_G:	cp "G"						;jpenner - "G" Entered?
			jr nz,CHECK_L				;jpenner - If not, Check L
			CALL ADDR_GO				;jpenner - LOAD: Load from Source to RAM
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_L:	cp "L"						;jpenner - "L" Entered?
			jr nz,CHECK_P				;jpenner - If not, Check P
			CALL LOAD_RAM				;jpenner - LOAD: Load from Source to RAM
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_P:	cp "P"						;jpenner - "P" Entered?
			jr nz,CHECK_S				;jpenner - If not, Check S
			CALL PANL_LED				;jpenner - Panel LED: Test Panel LEDs
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_S:	cp "S"						;jpenner - "S" Entered?
			jr nz,CHECK_BACK			;jpenner - If not, end
			CALL SAVE_RAM				;jpenner - SAVE: Save RAM data to media
			jp CHECK_DONE				;jpenner - Close out back to CR, Prompt and new line
CHECK_BACK:	djnz CHECK_LOOP				;jpenner - Repeat until 40 characters stored
CHECK_DONE:	jp CHECK_CMD_END			;jpenner - end
CHECK_ERR:  ld hl,ERR01					;jpenner - Point to "Invalid command" message
            ld b,ERR01_END - ERR01		;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display Error										Through VDP
			call ACT_BEL				;jpenner - Ring bell, Error!
CHECK_CMD_END:
			ret

HEX2NUM:	;jpenner - Routine was modified from a George Philips post in StackOverflow post 2014
			;jpenner - https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler
			;jpenner - Input: DE with 2 ASCII digits in HEX, Output: A with a number 0..99
			ld a,d					;jpenner - Get high Nibble
			call HEX_DIG				;jpenner - Convert to number
			add a,a						;jpenner - Multiple by 4
			add a,a						;jpenner -  Shifting Left 
			add a,a						;jpenner -  into upper nibble
			add a,a						;jpenner -  of A register
			ld d,a						;jpenner - Save number (upper nibble) result in D (First value)
			ld a,e						;jpenner - Get Low Nibble
			call HEX_DIG				;jpenner - Convert to number
			or d						;jpenner - Combine Upper nibble with Lower nibble
			ret							;jpenner - Return Number (in A) from ASCII (in DE)
HEX_DIG:
			add a,00h					;jpenner - In effect, clear the Carry flag
			sbc a,30h					;jpenner - This is a "0" (a-48)
			cp 0ah						;jpenner - Compare to a 10
			ret c						;jpenner - If overflow/carry return. this is a (0..9)
			sbc a,41h-30h-0ah			;jpenner - This is "A"-"0"-10=65-48-10=(a-7) (A..F)
			ret

NUM2HEX:	;jpenner - Routine was created using elements from a George Philips recorded in StackOverflow post 2012
			;jpenner - https://stackoverflow.com/questions/8119577/z80-daa-instruction
			;jpenner - Input: A with HEX value (num), Output: DE with 2 ASCII digits in HEX 
			push bc
			ld c,a						;jpenner - Save number to convert into C
			call DIGIT1					;jpenner - Convert Upper nibble to ASCII value
			ld d,a						;jpenner - Store ASCII Upper value
SKIP4:
			ld a,c						;jpenner - reload number to convert
			call DIGIT2					;jpenner - Convert Lower nibble to ASCII value
			ld e,a						;jpenner - Store ASCII Lower value
SKIP5:
			pop bc
			ret							;jpenner - Return with ASCII digits in DE
DIGIT1:		rra							;jpenner - Rotate right 4 bits pushing High Nibble to Low Nibble
			rra
			rra
			rra
DIGIT2:		and 0fh						;jpenner - Mask out upper 4 bits
			add a,90h
			daa
			adc a,40h
			daa  
			ret

ADDR_ENT:	;jpenner - Entering in, displaying, and edidting of a RAM Address
										;jpenner - Example
										;jpenner - :A{enter}
										;jpenner - :ADDR? 0A2F{enter}
										;jpenner - 0A2F:24 {enter}
										;jpenner - 0A30:FE FF{enter}
										;jpenner - 0A30:FF {enter}
										;jpenner - 0A31:2A {enter}
										;jpenner - 0A32:0C {Control C}

			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,ADDR_PMT				;jpenner - Point to message
			ld b,ADDR_PMT_END-ADDR_PMT	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
            ld a,(POS_X)				;jpenner - Get current X position
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			call ACT_BEL				;jpenner - Ring the bell
			call GET_LINE				;jpenner - Get a line
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
;Convert ASCII HEX Address to an address in BC
			ld hl,BUFF_IN				;jpenner - Point to entered in line
			ld d,(hl)					;jpenner - Expected first ASCII HEX digit (0..F)		2F7C	"2"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected second ASCII HEX digit (0..F)		2F7C	"F"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"2F" = 47
			ld b,a						;jpenner - Store in MSB of BC (B)
			inc hl						;jpenner - Next digit
			ld d,(hl)					;jpenner - Expected third ASCII HEX digit (0..F)		2F7C	"7"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected forth ASCII HEX digit (0..F)		2F7C	"C"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"7C" = 124
			ld c,a						;jpenner - Store in LSB of BC (C)
NEXT_ADDR:						;BC is the actual address viewing
			ld a,b						;jpenner - Get High byte of Address
			call NUM2HEX				;jpenner - Convert first MSB of address to 2 HEX Digits & Output
            ld a,d						;jpenner - Get high byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX1
            ld a,e						;jpenner - Get Low byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX2
			ld a,c						;jpenner - Get Low byte of address
			call NUM2HEX				;jpenner - Convert first LSB of address to 2 HEX Digits & Output
            ld a,d						;jpenner - Get high byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX3
            ld a,e						;jpenner - Get low byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX4
;
            ld a,3ah					;jpenner - Address/Value separator (:)
			out (VIDEO_DATA),a			;jpenner - Output ":"
;
			ld h,b						;jpenner - Move to HL (H) First Number					47
			ld l,c						;jpenner - Move to HL (L) Second Number					124
;Get addressed byte
			ld a,(hl)					;jpenner - Get value of the address to display
			call NUM2HEX				;jpenner - Convert address value to 2 HEX Digits & Output
            ld a,d						;jpenner - Get high byte
			out (VIDEO_DATA),a			;jpenner - Output High nibble HEX
            ld a,e						;jpenner - Get low byte
			out (VIDEO_DATA),a			;jpenner - Output Low nibble HEX
;Prompt & get new value
            ld a,20h					;jpenner - Value/Command separator ( )
			out (VIDEO_DATA),a			;jpenner - Output " "
            ld a,(POS_X)				;jpenner - Set X Position to 40 (trigger a new line)
			add 08h						;jpenner - Increment for output of 8 characters; "XXXX:XX_"
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			push bc						;jpenner - Note: AF & BC will change!!!! DE & HL are preserved
			ld a,02h					;jpenner - Set to get 2 characters
			call GET_HLINE				;jpenner - Get 2 character HEX and return BUFF_IN and actual 00..FF in A
;Manage input; replaced value, Enter, or Escape
			ld d,a						;jpenner - Hold Returned value (A) in (D)
			ld a,b						;jpenner - Get status (B) -00h=OK, FFh=Escape, FE=Return 
			cp 0ffh						;jpenner - Escape status set in B to FF, B=FF, Abort/Escape?
			jr z,ADDR_ENT_DONE			;jpenner - If so, Exit
			cp 0feh						;jpenner - Return status set in B to FE, B=FEh, No value returned?
			jr nz,VAL_REPLACE			;jpenner - If so, Move to next address																	
			pop bc						;jpenner - Restore BC before GET_LINE
			inc bc						;jpenner - Point to next address
			jr NEXT_ADDR				;jpenner - loop back to next address
VAL_REPLACE:
			ld a,d						;jpenner - Restore the returned value (00..FF)
			ld (hl),a					;jpenner - Set Character entered into RAM Address
			pop bc						;jpenner - Restore BC before GET_LINE
			inc bc						;jpenner - If a CR, get next Address
			jp NEXT_ADDR				;jpenner - Show next address
ADDR_ENT_DONE:
			xor a						;jpenner - Clear A on return
			pop bc						;jpenner - Restore BC before GET_LINE
			ret
ADDR_ENT_END:

DUMP_DAT:	;jpenner - Displaying Memory data starting at a RAM Address showing 8 bytes per row for 22 rows
										;jpenner - Example
										;jpenner - :M{enter}
										;jpenner - :ADDR? 0A2F{enter}
										;jpenner - 0A2F:24 00 34 A0 FF E4 12 C4  $.4.....
										;jpenner - 0A37:24 00 34 A0 FF E4 12 C4  $.4.....
										;jpenner - 0A3F:24 00 34 A0 FF E4 12 C4  $.4.....
										;jpenner - . . . . 
										;jpenner - 0AB7:FF 00 FF 00 FF 00 FF 00  ........
										;jpenner - >{enter or Control C}
										;jpenner - Enter to page more, control C to break out to ":" prompt

			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,ADDR_PMT				;jpenner - Point to message
			ld b,ADDR_PMT_END-ADDR_PMT	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
            ld a,(POS_X)				;jpenner - Get current X position
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			call ACT_BEL				;jpenner - Ring the bell
			call GET_LINE				;jpenner - Get a line
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
;Convert ASCII HEX Address to an address in BC
			ld hl,BUFF_IN				;jpenner - Point to entered in line
			ld d,(hl)					;jpenner - Expected first ASCII HEX digit (0..F)		2F7C	"2"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected second ASCII HEX digit (0..F)		2F7C	"F"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"2F" = 47
			ld b,a						;jpenner - Store in MSB of BC (B)
			inc hl						;jpenner - Next digit
			ld d,(hl)					;jpenner - Expected third ASCII HEX digit (0..F)		2F7C	"7"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected forth ASCII HEX digit (0..F)		2F7C	"C"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"7C" = 124
			ld c,a						;jpenner - Store in LSB of BC (C)
;BC is the address at this point!

NEXT_8PAGE:
		exx								;jpenner - Restore BC' (Row Counter) - SHADOW REGISTERS
		ld b,16h						;jpenner - Loop 22 times (Lines to display)
	
NEXT_8ADDR:						;BC is the actual address viewing
		exx								;jpenner - Restore BC (Address) - NORMAL REGISTERS
			ld a,b						;jpenner - Get High byte of Address
			call NUM2HEX				;jpenner - Convert first MSB of address to 2 HEX Digits & Output
            ld a,d						;jpenner - Get high byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX1
            ld a,e						;jpenner - Get Low byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX2
			ld a,c						;jpenner - Get Low byte of address
			call NUM2HEX				;jpenner - Convert first LSB of address to 2 HEX Digits & Output
            ld a,d						;jpenner - Get high byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX3
            ld a,e						;jpenner - Get low byte ASCII value
			out (VIDEO_DATA),a			;jpenner - Output HEX4
;
            ld a,3ah					;jpenner - Address/Value separator (:)
			out (VIDEO_DATA),a			;jpenner - Output ":"
            ld a,20h					;jpenner - Value/Command separator ( )
			out (VIDEO_DATA),a			;jpenner - Output " "
;
			ld h,b						;jpenner - Move to HL (H) First Number					47
			ld l,c						;jpenner - Move to HL (L) Second Number					124
;Get addressed bytes and show HEX
		push bc	;needed?
            ld a,08h					;jpenner - Set count to 8 itterations
			ld b,a						;jpenner - Set the counter
DUMP_LOOP1:	ld a,(hl)					;jpenner - Get value of the address to display
			call NUM2HEX				;jpenner - Convert address value to 2 HEX Digits & Output
            ld a,d						;jpenner - Get high byte
			out (VIDEO_DATA),a			;jpenner - Output High nibble HEX
            ld a,e						;jpenner - Get low byte
			out (VIDEO_DATA),a			;jpenner - Output Low nibble HEX
            ld a,20h					;jpenner - Value/Command separator ( )
			out (VIDEO_DATA),a			;jpenner - Output " "
			inc hl
			djnz DUMP_LOOP1
		pop bc	;needed?	

            ld a,20h					;jpenner - Value/Command separator ( )
			out (VIDEO_DATA),a			;jpenner - Output " "
;Get addressed bytes and show ASCII
			ld hl,bc
		push bc	;needed?
            ld a,08h					;jpenner - Set count to 8 itterations
			ld b,a						;jpenner - Set the counter
DUMP_LOOP2:	ld a,(hl)					;jpenner - Get value of the address to display
			push af
			scf							;jpenner - Set Carry Flag
			sbc a,1fh					;jpenner - (31+c=32) If carry set, implies Charater is in range of 00-1F; non-printable
			jp c,DSP_DOT				;jpenner - Display a "."
			scf							;jpenner - Set Carry Flag
			sbc a,3ah					;jpenner - (58+c=59) Pull value down more...If No carry set, implies Charater is beyond NABU Printable characters in range of 5B-FF; A-20h-3Bh.....Other printable
			jr nc,DSP_DOT				;jpenner - Treat as an other extended character
			pop af						;jpenner - Get original value
			jr DSP_ASCII				;jpenner - Display printable character
DSP_DOT:	pop af						;jpenner - Get original value
			ld a,"."					;jpenner - Set the ASCII value to a "."
DSP_ASCII:	OUT (VIDEO_DATA),a			;jpenner - Output the "," or ASCII Character
            inc hl						;jpenner - point to next address
			djnz DUMP_LOOP2				;jpenner - Get next value
		pop bc	;needed?	

            ld a,28h					;jpenner - Set X Position to 40 (trigger a new line)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping

;Loop through 22 lines
            ld b,h
			ld c,l
		exx								;jpenner - Restore BC' (Row Counter) - SHADOW REGISTERS
			djnz NEXT_8ADDR				;jpenner - Display next row
		exx								;jpenner - Restore BC (Address) - NORMAL REGISTERS
			
;Manage input; replaced value, Enter, or Escape
			push bc						;jpenner - Note: AF & BC will change!!!! DE & HL are preserved
			ld a,01h					;jpenner - Set to get 1 character
			call GET_HLINE				;jpenner - Get 1 character HEX and return BUFF_IN and actual 00..FF in A
			ld d,a						;jpenner - Hold A in D
			ld a,b						;jpenner - 
			cp 0ffh						;jpenner - Escape status set in B to FF, B=FF, Abort/Escape?
			jr z,DUMP_DAT_DONE			;jpenner - If so, Exit
			cp 0feh						;jpenner - Return status set in B to FE, B=FEh, No value returned?
			jr nz,DUMP_CHAR_EXC			;jpenner - If so, Move to next address																	
			pop bc						;jpenner - Restore BC before GET_LINE
;			inc bc						;jpenner - Point to next address
			jr NEXT_8PAGE				;jpenner - loop back to next address and next Page
DUMP_CHAR_EXC:
			pop bc						;jpenner - Restore BC before GET_LINE
			inc bc						;jpenner - If a CR, get next Address
			jp NEXT_8PAGE				;jpenner - Show next Page
DUMP_DAT_DONE:
			pop bc						;jpenner - Restore BC before GET_LINE
			xor a						;jpenner - Clear A on return
DUMP_DAT_END:
			ret

OPER_REG:	;jpenner - Display registers & Operation values
										;jpenner - Display of Current Register settings
										;jpenner - A F   B C   D E   H L   I X   I Y
										;jpenner - 31E5  03CA  0001  06E0  0000  0000
										;jpenner - STATUS (F)  S  Z  X  H  X  PV N  C
										;jpenner -             1  1  1  0  0  1  0  1
										;jpenner - CONTROL REG R2 R1 LP LA LC RF PS RE
										;jpenner -             1  1  1  0  0  1  0  1
            push af
			push bc
			push de
			push hl

			ld (REG_HOLD),a
			ld a,d
			ld (REG_HOLD+01h),a
			ld a,e
			ld (REG_HOLD+02h),a
			ld de,BUFF_IN				;jpenner - Point to Line buffer           
			ld a,(REG_HOLD)				;jpenner - Restore A
			ld (de),a					;jpenner - Save A Register
			inc de						;jpenner - Point to next character spot in buffer
;			ld a,f						;jpenner - Load F Register - F is not accessible like this
										;jpenner - 	7	6	5	4	3	2	1	0
										;jpenner - 	S	Z	-	H	-	P	N	C
			xor a						;jpenner - Clear A; set to 0000 0000
			jp m,nf1					;jpenner - Is the Sign flag set to Minus? [P/M]
			res 7,a						;jpenner - Clear bit 7: 0------- 
			jp nf2						;jpenner - Check next bit
nf1:		set 7,a						;jpenner - Set bit   7: 1-------
nf2:		jp z,nf3					;jpenner - Is the Zero flag set?
			res 6,a						;jpenner - Clear bit 6: -0------
			jp nf4						;jpenner - Check next bit
nf3:		set 6,a						;jpenner - Set bit   6: -1------
nf4:		res 5,a						;jpenner - Clear bit 5: --0-----
			set 4,a						;jpenner - Set bit   4: ---0---- 
			res 3,a						;jpenner - Clear bit 3: ----0--- 
			jp pe,nf5					;jpenner - Is the Parity/Overflow set to Even? [PE/PO]
			res 2,a						;jpenner - Clear bit 2: -----0-- 
			jp nf6						;jpenner - Check next bit
nf5:		set 2,a						;jpenner - Set bit   2: -----1-- 
nf6:		res 1,a						;jpenner - Clear bit 1: ------0- 
			jp c,nf7						;jpenner - Is the Subtraction flag set? [N/]
			res 0,a						;jpenner - Clear bit 0: -------0 
			jp nf8						;jpenner - Done
nf7:		set 0,a						;jpenner - Set bit   0: -------1 
nf8:	
;			ld a,3Eh					;jpenner - Load F Register - Dummy value
			ld (de),a					;jpenner - Save F Register
			inc de						;jpenner - Point to next character spot in buffer
			ld a,20h					;jpenner - Set " "
			ld (de),a					;jpenner - Save " "
			inc de						;jpenner - Point to next character spot in buffer
			ld a,20h					;jpenner - Set " "
			ld (de),a					;jpenner - Save " "
			inc de						;jpenner - Point to next character spot in buffer
			ld a,b						;jpenner - Load B Register
			ld (de),a					;jpenner - Save B Register
			inc de						;jpenner - Point to next character spot in buffer
			ld a,c						;jpenner - Load C Register
			ld (de),a					;jpenner - Save C Register
			inc de						;jpenner - Point to next character spot in buffer
			ld a,20h					;jpenner - Set " "
			ld (de),a					;jpenner - Save " "
			inc de						;jpenner - Point to next character spot in buffer
			ld a,20h					;jpenner - Set " "
			ld (de),a					;jpenner - Save " "
			inc de						;jpenner - Point to next character spot in buffer
			ld a,(REG_HOLD+01h)			;jpenner - Restore D
			ld (de),a					;jpenner - Save D Register
			inc de						;jpenner - Point to next character spot in buffer
			ld a,(REG_HOLD+02h)			;jpenner - Restore D
			ld (de),a					;jpenner - Save E Register
			inc de						;jpenner - Point to next character spot in buffer
			ld a,20h					;jpenner - Set " "
			ld (de),a					;jpenner - Save " "
			inc de						;jpenner - Point to next character spot in buffer
			ld a,20h					;jpenner - Set " "
			ld (de),a					;jpenner - Save " "
			inc de						;jpenner - Point to next character spot in buffer
			ld a,h						;jpenner - Load H Register
			ld (de),a					;jpenner - Save H Register
			inc de						;jpenner - Point to next character spot in buffer
			ld a,l						;jpenner - Load L Register
			ld (de),a					;jpenner - Save L Register
			inc de						;jpenner - Point to next character spot in buffer
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,REG1_MSG				;jpenner - Point to message
			ld b,REG1_MSG_END-REG1_MSG	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message

            ld hl,BUFF_IN				;jpenner - Point to Line buffer           
			ld b,0eh					;jpenner - Set number of characters to display (15 characters)
OPER_LOOP:	ld a,(hl)					;jpenner - Get High byte of Address
			cp 20h						;jpenner - Check for space
			jr z,DSP_SPC				;jpenner - Jump to display a space
			call NUM2HEX				;jpenner - Convert value(A) to 2 HEX Digits(DE)
			ld a,d						;jpenner - Get HEX value - High Nibble			
			call DISPLAY_CHAR			;jpenner - Display HEX character
			ld a,e						;jpenner - Get HEX value - Low Nibble
DSP_SPC:	call DISPLAY_CHAR			;jpenner - Display HEX character
OPER_SKP:	inc hl						;jpenner - Point to next buffer position
			djnz OPER_LOOP				;jpenner - Loop to next buffer position
								;jpenner - Display the F register header
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,REG2_MSG				;jpenner - Point to message
			ld b,REG2_MSG_END-REG2_MSG	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
			ld a,0Ch					;jpenner - Set to 14 Columns in 
            ld (POS_X),a				;jpenner - Set X Position to 13
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
								;jpenner - Display the F register bits
            ld hl,BUFF_IN				;jpenner - Point to Line buffer           
			inc hl						;jpenner - Point to where F register is saved
			ld a,(HL)					;jpenner - Get value of F register saved ealier
			ld b,08h					;jpenner - Number of bits to loop through
BIT_WALK1:
;			push af						;jpenner - Set aside the A register (holding F bits)
;			ld a,b						;jpenner - Get the currnet bit count
;			cp 06h						;jpenner - Is this bit position 6 (bit 5)?
;			jp nz,SKIP6				;jpenner - If not skip
;			ld c,2Dh					;jpenner - Set the display character to "-"
;			pop af						;jpenner - Bring back the A register (holding F bits)
;			jp SHOW_BIT1				;jpenner - ...and resume to display value and loop again
;SKIP6:		cp 04h						;jpenner - Is this bit position 4 (bit 3)?
;			jp nz,SKIP7				;jpenner - If not skip
;			ld c,2Dh					;jpenner - Set the display character to "-"
;			pop af						;jpenner - Bring back the A register (holding F bits)
;			jp SHOW_BIT1				;jpenner - ...and resume to display value and loop again
;SKIP7:		pop af						;jpenner - Bring back the A register (holding F bits)
			rlc	a						;jpenner - Rotate Left bit of A onto Carry flag
			jr c,SET_BIT1				;jpenner - If Carry, set the bit
			ld c,30h					;jpenner - Set A to "0"
			jr SHOW_BIT1				;jpenner - Show the "0"
SET_BIT1:	ld c,31h					;jpenner - Set A to "1"
SHOW_BIT1:	push af						;jpenner - Preserve A
			ld a,c						;jpenner - Load bit in to A for display (A<-C)
			out (VIDEO_DATA),a			;jpenner - Output Bit
			ld a,20h					;jpenner - Set " "
			out (VIDEO_DATA),a			;jpenner - Output " "
			out (VIDEO_DATA),a			;jpenner - Output " "
			pop af						;jpenner - Restore A
			djnz BIT_WALK1				;jpenner - Repeat through all bits
								;jpenner - Display the Control Register header
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,REG3_MSG				;jpenner - Point to message
			ld b,REG3_MSG_END-REG3_MSG	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
			ld a,0Ch					;jpenner - Set to 14 Columns in 
            ld (POS_X),a				;jpenner - Set X Position to 13
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
								;jpenner - Display the Control Register State bits
			ld a,(CNTRL_STATE)			;jpenner - Get value of Control Register State saved ealier
			ld b,08h					;jpenner - Number of bits to loop through
BIT_WALK2:	rlc	a						;jpenner - Rotate Left bit of A onto Carry flag
			jr c,SET_BIT2				;jpenner - If Carry, set the bit
			ld c,30h					;jpenner - Set A to "0"
			jr SHOW_BIT2				;jpenner - Show the "0"
SET_BIT2:	ld c,31h					;jpenner - Set A to "1"
SHOW_BIT2:	push af						;jpenner - Preserve A
			ld a,c						;jpenner - Load bit in to A for display (A<-C)
			out (VIDEO_DATA),a			;jpenner - Output Bit
			ld a,20h					;jpenner - Set " "
			out (VIDEO_DATA),a			;jpenner - Output " "
			out (VIDEO_DATA),a			;jpenner - Output " "
			pop af						;jpenner - Restore A
			djnz BIT_WALK2				;jpenner - Repeat through all bits

			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			
			pop hl
			pop de
			pop bc
			pop af
			ret
OPER_REG_END:

COPY_PST:
;Get Source Address
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,SORC_ADR				;jpenner - Point to message
			ld b,SORC_ADR_END-SORC_ADR	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
            ld a,(POS_X)				;jpenner - Get current X position
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			call ACT_BEL				;jpenner - Ring the bell
			call GET_LINE				;jpenner - Get a line
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
;Convert ASCII HEX Address to an address in BC
			ld hl,BUFF_IN				;jpenner - Point to entered in line
			ld d,(hl)					;jpenner - Expected first ASCII HEX digit (0..F)		2F7C	"2"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected second ASCII HEX digit (0..F)		2F7C	"F"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"2F" = 47
			ld b,a						;jpenner - Store in MSB of BC (B)
			inc hl						;jpenner - Next digit
			ld d,(hl)					;jpenner - Expected third ASCII HEX digit (0..F)		2F7C	"7"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected forth ASCII HEX digit (0..F)		2F7C	"C"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"7C" = 124
			ld c,a						;jpenner - Store in LSB of BC (C)
			push bc						;jpenner - This will be HL (SOURCE)

;Get Destination address
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,DEST_ADR				;jpenner - Point to message
			ld b,DEST_ADR_END-DEST_ADR	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
            ld a,(POS_X)				;jpenner - Get current X position
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			call ACT_BEL				;jpenner - Ring the bell
			call GET_LINE				;jpenner - Get a line
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
;Convert ASCII HEX Address to an address in BC
			ld hl,BUFF_IN				;jpenner - Point to entered in line
			ld d,(hl)					;jpenner - Expected first ASCII HEX digit (0..F)		2F7C	"2"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected second ASCII HEX digit (0..F)		2F7C	"F"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"2F" = 47
			ld b,a						;jpenner - Store in MSB of BC (B)
			inc hl						;jpenner - Next digit
			ld d,(hl)					;jpenner - Expected third ASCII HEX digit (0..F)		2F7C	"7"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected forth ASCII HEX digit (0..F)		2F7C	"C"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"7C" = 124
			ld c,a						;jpenner - Store in LSB of BC (C)
			push bc						;jpenner - This will be DE (DESTINATION)

;Get Byte Count
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,BYTE_CNT				;jpenner - Point to message
			ld b,BYTE_CNT_END-BYTE_CNT	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
            ld a,(POS_X)				;jpenner - Get current X position
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			call ACT_BEL				;jpenner - Ring the bell
			call GET_LINE				;jpenner - Get a line
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
;Convert ASCII HEX Address to an address in BC
			ld hl,BUFF_IN				;jpenner - Point to entered in line
			ld d,(hl)					;jpenner - Expected first ASCII HEX digit (0..F)		2F7C	"2"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected second ASCII HEX digit (0..F)		2F7C	"F"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"2F" = 47
			ld b,a						;jpenner - Store in MSB of BC (B)
			inc hl						;jpenner - Next digit
			ld d,(hl)					;jpenner - Expected third ASCII HEX digit (0..F)		2F7C	"7"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected forth ASCII HEX digit (0..F)		2F7C	"C"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"7C" = 124
			ld c,a						;jpenner - Store in LSB of BC (C)
			push bc						;jpenner - This will be BC (BYTE COUNT)

;Copy & Paste data
			pop bc						;jpenner - Get BYTE COUNT (BC)
			pop de						;jpenner - Get DESTINATION (DE)
			pop hl						;jpenner - Get SOURCE (HL)
			LDIR

			ret
COPY_PST_END:

HELP_TXT:
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,HELP_MSG				;jpenner - Point to message
			ld b,HELP_MSG_END-HELP_MSG	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
;			ld a,28h					;jpenner - Set end of row+1 (39+1)
;			ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
;			call POS_CURSOR			;jpenner - Cursor correct and Adjust Address mapping
			ret
HELP_TXT_END:

ADDR_GO:
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
			ld hl,ADDR_PMT				;jpenner - Point to message
			ld b,ADDR_PMT_END-ADDR_PMT	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
            ld a,(POS_X)				;jpenner - Get current X position
			ld (SOL_MARKER),a			;jpenner - Mark as Start Of Line
			call ACT_BEL				;jpenner - Ring the bell
			call GET_LINE				;jpenner - Get a line
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
;Convert ASCII HEX Address to an address in BC
			ld hl,BUFF_IN				;jpenner - Point to entered in line
			ld d,(hl)					;jpenner - Expected first ASCII HEX digit (0..F)		2F7C	"2"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected second ASCII HEX digit (0..F)		2F7C	"F"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"2F" = 47
			ld b,a						;jpenner - Store in MSB of BC (B)
			inc hl						;jpenner - Next digit
			ld d,(hl)					;jpenner - Expected third ASCII HEX digit (0..F)		2F7C	"7"
			inc hl						;jpenner - Next digit
			ld e,(hl)					;jpenner - Expected forth ASCII HEX digit (0..F)		2F7C	"C"
			call HEX2NUM				;jpenner - Convert 2 ASCII HEX digits to a number		2F7C	"7C" = 124
			ld c,a						;jpenner - Store in LSB of BC (C)
;BC is the address at this point!
			ld h,b						;jpenner - Transfer address from bc to hl
			ld l,c						;jpenner - Transfer address from bc to hl
			jp (hl)						;jpenner - Leave BIOS and Jump/Go to Address
			ret
ADDR_GO_END:
			
PANL_LED:
			ld a,28h					;jpenner - Set end of row+1 (39+1)
            ld (POS_X),a				;jpenner - Set X Position to 40 (trigger a new line)
			call POS_CURSOR				;jpenner - Cursor correct and Adjust Address mapping
;		ld a,0Bh					;jpenner - Black Letters/Forground and Yellow/Transparent/Background 
;		out (VIDEO_LATCH),a			;jpenner - Set Foreground/background (00001010)
;		ld a,87h					;jpenner - Set e to 87h	(Register 7)
;		out (VIDEO_LATCH),a			;jpenner - Set register 7
;		ld a,20h					;jpenner - Set " "
;		out (VIDEO_DATA),a			;jpenner - Output " "
;		ld a,06h					;jpenner - Black Letters/Forground and Red/Transparent/Background 
;		out (VIDEO_LATCH),a			;jpenner - Set Foreground/background (00000110)
;		ld a,87h					;jpenner - Set e to 87h	(Register 7)
;		out (VIDEO_LATCH),a			;jpenner - Set register 7
;		ld a,20h					;jpenner - Set " "
;		out (VIDEO_DATA),a			;jpenner - Output " "
;		ld a,0Bh					;jpenner - Black Letters/Forground and Blue/Transparent/Background 
;		out (VIDEO_LATCH),a			;jpenner - Set Foreground/background (00000100)
;		ld a,87h					;jpenner - Set e to 87h	(Register 7)
;		out (VIDEO_LATCH),a			;jpenner - Set register 7
;		ld a,20h					;jpenner - Set " "
;		out (VIDEO_DATA),a			;jpenner - Output " "
;		ld a,0B0h					;jpenner - Yellow Letters/Forground and Black/Transparent/Background 
;		out (VIDEO_LATCH),a			;jpenner - Set Foreground/background (10100000)
;		ld a,87h					;jpenner - Set e to 87h	(Register 7)
;		out (VIDEO_LATCH),a			;jpenner - Set register 7
;		ld a,20h					;jpenner - Set " "
;		out (VIDEO_DATA),a			;jpenner - Output " "
;		ld a,04h					;jpenner - Set to Column 4
;      ld (POS_X),a				;jpenner - Set X
			ld hl,PANL_MSG				;jpenner - Point to message
			ld b,PANL_MSG_END-PANL_MSG	;jpenner - Set B as character counter supporting DJNZ
			call MSG_DISPLAY			;jpenner - Display message
            ld a,(CNTRL_STATE)			;jpenner - Get the last preserved Control Register State
			and 0C7h					;jpenner - Clear LED bits and mask others
			out (CNTRL_REG),a			;jpenner - Turn on LEDs off
			ld b,05h					;jpenner - Loop 5 times
PANL_STRT:	ld hl,35C6h					;jpenner - Delay 13,766 cycles
            call DELAY					;jpenner - Delay 1/10 second...T-States 3.75Mhz/ 31 + (26*HL) - 5
			set 5,a						;jpenner - Set   for LED 2-Pause-Yellow to come on 0010 0000 = 20h
			res 3,a						;jpenner - Reset for LED 1-Check-Blue   to come on 0000 1000 = 08h
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
            ld hl,35C6h					;jpenner - Delay 13,766 cycles
            call DELAY					;jpenner - Delay 1/10 second...T-States 3.75Mhz/ 31 + (26*HL) - 5
			res 5,a						;jpenner - Reset for LED 2-Pause-Yellow to come on 0010 0000 = 20h
			set 4,a						;jpenner - Set   for LED 3-Alert-Red    to come on 0001 0000 = 10h
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
            ld hl,35C6h					;jpenner - Delay 13,766 cycles
            call DELAY					;jpenner - Delay 1/10 second...T-States 3.75Mhz/ 31 + (26*HL) - 5
			res 4,a						;jpenner - Reset for LED 3-Alert-Red    to come on 0001 0000 = 10h
			set 3,a						;jpenner - Set   for LED 1-Check-Blue   to come on 0000 1000 = 08h
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
            ld hl,35C6h					;jpenner - Delay 13,766 cycles
            call DELAY					;jpenner - Delay 1/10 second...T-States 3.75Mhz/ 31 + (26*HL) - 5
			djnz PANL_STRT
			res 3,a						;jpenner - Reset for LED 1-Check-Blue   to come on 0000 1000 = 08h
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
;
            ld a,(CNTRL_STATE)			;jpenner - Get the last preserved Control Register State
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
			push af						;jpenner - Accumulator saved for Keyboard use
PANL_LOOP:	in a,(KEYBD_STATUS)			;jpenner - Get status word from USART (Keyboard)
            bit 1,a 					;jpenner - Check for bit 1 (RxRDY) for received character
            jr z,PANL_LOOP				;jpenner - Continue to show LEDs until bit 1 (RxRDY) is set [......1.]
            in a,(KEYBD_DATA)			;jpenner - Receive Keyboard character
			cp 31h						;jpenner - Is the key a "1" (30h)?
			jr nz,SKIP1					;jpenner - If not, skip
			pop af						;jpenner - Accumulator returned to LED Control Register
			xor 20h						;jpenner - Toggle bit 5 for LED 2-Pause-Yellow to come on 0010 0000 = 20h
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
			push af						;jpenner - Accumulator return to Keyboard
			jp PANL_LOOP				;jpenner - Scan for next key
SKIP1:		cp 32h						;jpenner - Is the key a "1" (30h)?
			jr nz,SKIP2					;jpenner - If not, skip
			pop af						;jpenner - Accumulator returned to LED Control Register
			xor 10h						;jpenner - Toggle bit 4 for LED 3-Alert-Red    to come on 0001 0000 = 10h
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
			push af						;jpenner - Accumulator return to Keyboard
			jp PANL_LOOP				;jpenner - Scan for next key
SKIP2:		cp 33h						;jpenner - Is the key a "1" (30h)?
			jr nz,SKIP3					;jpenner - If not, skip
			pop af						;jpenner - Accumulator returned to LED Control Register
			xor 08h						;jpenner - Toggle bit 3 for LED 1-Check-Blue   to come on 0000 1000 = 08h
			out (CNTRL_REG),a			;jpenner - Turn on LED and others off
			push af						;jpenner - Accumulator return to Keyboard
			jp PANL_LOOP				;jpenner - Scan for next key
SKIP3:		cp 1Bh						;jpenner - Is the key a Escape (1Bh)?
			jr nz,PANL_LOOP				;jpenner - Repeat if no Escape key
			pop af						;jpenner - Restor the stack
            ld (CNTRL_STATE),a			;jpenner - Set the Control Register State
;
			ret
PANL_LED_END:

LOAD_RAM:
			ret
LOAD_RAM_END:

SAVE_RAM:
			ret
SAVE_RAM_END:

ACT_BEL:
			push af
			push hl
			ld a,07h					;jpenner - R7 - Mixer control - I/O Enable
            out (SOUND_LATCH),a			;jpenner - R7 - Point to Register 7
            ld a,03eh					;jpenner - R7 - Set to 0011 1110 (Channel A Tone Enabled)
            out (SOUND_DATA),a			;jpenner - R7 - Set register settings
            ld hl,6B8Dh					;jpenner - Delay 27,533 cycles
            call DELAY					;jpenner - Delay 1/5 second...T-States 3.75Mhz/ 31 + (26*HL) - 5
			ld a,07h					;jpenner - R7 - Mixer control - I/O Enable
            out (SOUND_LATCH),a			;jpenner - R7 - Point to Register 7
            ld a,03fh					;jpenner - R7 - Set to 0011 1111 (All Noise & Tone Channels Disabled)
            out (SOUND_DATA),a			;jpenner - R7 - Set register settings
            ld hl,6B8Dh					;jpenner - Delay 27,533 cycles
            call DELAY					;jpenner - Delay 1/5 second...T-States 3.75Mhz/ 31 + (26*HL) - 5
			pop hl
			pop af
 			ret
ACT_BEL_END:

POS_CURSOR:					;jpenner - Address screen wrapping and set correct/intended X,Y Position
			push af						;jpenner - Save character entered
POS_FWD:							;jpenner - Forward movement: (X has moved forward +1)
            ld a,(POS_X)				;jpenner - Get X position
            cp 28h						;jpenner - Check X for end of line (wrap) 40 (0..39)
            jr nz,POS_BAK				;jpenner - Done or check for backspace boundries
            ld a,00h					;jpenner - Set Column 0
            ld (POS_X),a				;jpenner - Set X Position to 00 (trigger a new line)
            ld a,(POS_Y)				;jpenner - get current Y position
            inc a						;jpenner - Move Y down 1 row
			ld (POS_Y),a				;jpenner - Save Y Position
			cp 18h						;jpenner - Last row already?
			jp nz,POS_DONE				;jpenner - done
			ld a,17h					;jpenner - keep Y at last row 23 (0..23)
            ld (POS_Y),a				;jpenner - Set Y Position at 23 (Keep at same point)
			call MOV_SCREEN_UP			;jpenner - Move screen up (Row 1, becomes Row 0.....Row 23 is blank)
			jp POS_DONE					;jpenner - Exit
POS_BAK:							;jpenner - Backward movement: (X has moved backward -1)
            cp 0ffh						;jpenner - Check for beyond beginning of line (wrap) (-1)[FF or 7F] (0..39)
            jr nz,POS_DONE				;jpenner - Done
            ld a,27h					;jpenner - Set Column 39
            ld (POS_X),a				;jpenner - Set X Position to 39 (trigger a previous line)
            ld a,(POS_Y)				;jpenner - get current Y position
            dec a						;jpenner - Move Y up 1 row
            ld (POS_Y),a				;jpenner - Set Y Position
 			cp 0ffh						;jpenner - First row already?
			jp nz,POS_DONE				;jpenner - done
			call ACT_BEL				;jpenner - Ring Bell
            ld a,00h					;jpenner - Set Column 0
            ld (POS_X),a				;jpenner - Set X Position to 00 (BOL)
            ld a,00h					;jpenner - Set Column 0
            ld (POS_Y),a				;jpenner - Set Y Position to 00 (TOR)
			jp POS_DONE
POS_DONE:
;			call VDP_ADD_CORRECT1		;jpenner - Correct VDP Address based on X/Y Position (James)
			call VDP_ADD_CORRECT2		;jpenner - Correct VDP Address based on X/Y Position (Mike)
			pop af						;jpenner - Restore character entered
			ret

MOV_SCREEN_UP:
			push af						;jpenner - Genaeral use
            push bc						;jpenner - B=character count, C=Row count down
            push de						;jpenner - buffer location & Temp value for add/sub to HL
            push hl						;jpenner - VDP address (0..960)
            ld hl,0028h					;jpenner - Set starting VDP position (1st character on second row)
            ld c,017h					;jpenner - Set number of rows to move up (23)

NEXT_ROW_LOOP:         
			ld a,l						;jpenner - Get LSB of l Initially 28h
            out (VIDEO_LATCH),a			;jpenner - Set VDP LSB
            ld a,h						;jpenner - Get MSB of h Initially 00h
            out (VIDEO_LATCH),a			;jpenner - Set VDP MSB

            ld de,TEMP_ROW_ARRAY		;jpenner - Point to Temporary Row array (40 character buffer)            
            ld b,028h					;jpenner - 40 character count
STORE_ROW_LOOP:
			in a,(VIDEO_DATA)			;jpenner - Get the row character
            ld (de),a					;jpenner - Store row character in Temp buffer
            inc de						;jpenner - Point to next Temp buffer location for next character storage
            djnz STORE_ROW_LOOP			;jpenner - Repeat until 40 characters stored

			ld de,0027h					;jpenner - Set to 1 row (40 characters) - 1 (to accomidate Carry flag)
			scf							;jpenner - Set Carry Flag as this is used in SBC
			sbc hl,de					;jpenner - Back up one row
			ld a,l						;jpenner - Get LSB of l
            out (VIDEO_LATCH),a			;jpenner - Set VDP LSB
            ld a,h						;jpenner - Get MSB of h 
            or 40h						;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
            out (VIDEO_LATCH),a			;jpenner - Set VDP MSB

            ld de,TEMP_ROW_ARRAY		;jpenner - Point to Temporary Row array (40 character buffer)            
            ld b,028h					;jpenner - 40 character count
RESTORE_ROW_LOOP:
            ld a,(de)					;jpenner - Get the row character from Temp buffer
			out (VIDEO_DATA),a			;jpenner - Set the row character
            inc de						;jpenner - Point to next Temp buffer location for next character storage
            djnz RESTORE_ROW_LOOP		;jpenner - Repeat until 40 characters stored
	
			ld de,0050h					;jpenner - Set to two rows (80 characters)
			add hl,de					;jpenner - Point to next Row
            dec c						;jpenner - Count down rows to Zero
            jp nz,NEXT_ROW_LOOP			;jpenner - Continue until 23 rows are copied up
LAST_ROW:
			ld de,0027h					;jpenner - Set to 1 row (40 characters) - 1 (to accomidate Carry flag)
			scf							;jpenner - Set Carry Flag as this is used in SBC
			sbc hl,de					;jpenner - Back up one row (from 24 to 23)
			ld a,l						;jpenner - Get LSB of l
            out (VIDEO_LATCH),a			;jpenner - Set VDP LSB
            ld a,h						;jpenner - Get MSB of h 
            or 40h						;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
            out (VIDEO_LATCH),a			;jpenner - Set VDP MSB

            ld b,028h					;jpenner - 40 character count
BLANK_LAST_ROW:
            ld a,20h					;jpenner - Get " " (Space) to blank row
			out (VIDEO_DATA),a			;jpenner - Set the row character
            djnz BLANK_LAST_ROW			;jpenner - Repeat until 40 characters stored

			pop hl
            pop de
            pop bc
			pop af
			ret

VDP_ADD_CORRECT1:						;jpenner - (James) In essense this is [(Y*40)+X]+0x4000h = VDP_ADD - (Less Storage?)
			push af
            push bc
			push de
            push hl
			ld a,(POS_Y)				;jpenner - Use B for the loop counter (Y Rows)
			ld b,a						;jpenner - Move A to upper byte of BC (B)
			ld hl,0						;jpenner - Initialize the accumulated result HL; Result will be D*E
			ld a,b						;<Fix a already =b: jpenner - Checking if Y Row is Zero, then skipping
			or a						;jpenner - Check for Zero
			jp z,MULTI_SKIP				;jpenner - Skip to add X Column
			ld d,00h					;jpenner - Set D of DE to 00h
			ld e,28h					;jpenner - Set E of DE to 28h or 40 column row
MULTI_LOOP:								;jpenner - Multiply by adding DE to HL, B times
			add hl,de					;jpenner - Accumulate 40 in HL
			djnz MULTI_LOOP				;jpenner - check if B counter is Zero
MULTI_SKIP:
			ld b,00h					;jpenner - Clear B (In theory, B is cleared)
            ld a,(POS_X)				;jpenner - Get the current Column (0..39)
            ld c,a						;jpenner - Move A to lower byte of BC (C)
            add hl,bc					;jpenner - Add X Column position for full offset
            ld a,l						;jpenner - Take the offset Low byte and...
            out (VIDEO_LATCH),a			;jpenner - Set the VDP Low byte
            ld a,h						;jpenner - Take the offset High byte and...
            or 40h						;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
            out (VIDEO_LATCH),a			;jpenner - Set the VDP High Byte
            pop hl
            pop bc
			pop de
            pop af
			ret

VDP_ADD_CORRECT2:						;jpenner - (Mike) In essense this is [(Y*40)+X]+0x4000h = VDP_ADD (Faster performance?)
			push af
            push bc
            push hl
            ld hl,ROW_OFFSET_ARRAY		;jpenner - Point to address of row offsets
            ld a,(POS_Y)				;jpenner - Get the current Row (0..23)
            add a,a						;jpenner - Double Row as this will be used as an offset for finding the correct Row address offset
            ld c,a						;jpenner - Store in Low byte of BC (C)
            ld b,00h					;jpenner - Zero High byte of BC (B)
            add hl,bc					;jpenner - Add BC to HL
            ld c,(hl)					;jpenner - Get offset High byte, store in C
            inc hl						;jpenner - Point to next offset byte location
            ld b,(hl)					;jpenner - Get offset to Low byte, store in B (BC is Row Offset)
            ld a,(POS_X)				;jpenner - Get the current Column (0..39)
            ld l,a						;jpenner - Store in Low byte of HL (L)
            ld h,00h					;jpenner - Zero High byte of HL (H) (HL is Column offset)
            add hl,bc					;jpenner - Get the address offset of the Row & Column
            ld a,l						;jpenner - Take the offset Low byte and...
            out (VIDEO_LATCH),a			;jpenner - Set the VDP Low byte
            ld a,h						;jpenner - Take the offset High byte and...
            or 40h						;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
            out (VIDEO_LATCH),a			;jpenner - Set the VDP High Byte
            pop hl
            pop bc
            pop af
			ret

VIDEO_INIT:
			xor a						;jpenner - Set A to 00h LSB
			out (VIDEO_LATCH),a			;jpenner - Set Lower address byte to VDP Address 0000 0000 00h (4000h)
			ld a,40h					;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
			out (VIDEO_LATCH),a			;jpenner - Set Upper address byte to VDP Address 0000 0100 40h (4000h)

VIDEO_RAM_CLEAR:    				    ;jpenner - Clear 16Kb of VDP memory
			ld b,FILL_CHAR				;jpenner - Set B to 20h; See declarations to change. A change to a visible character helps with screen testing
			ld hl,3FFFh					;jpenner - Set HL address to 03FFFh (Top of Video RAM)
VIDEO_CLEAR_LOOP:
			ld a,b
			out (VIDEO_DATA),a			;jpenner - Set 00h on the VDP port
			dec hl						;jpenner - Decrament the VDP RAM Address
			ld a,h						;jpenner - Capture High byte and...
			or l						;jpenner - OR with Low byte to determine if HL is Zero (0)
            nop							;jpenner - Supports a 4 clock cycle wait for VDP to catch up
            nop							;jpenner - Supports a 4 clock cycle wait for VDP to catch up
			jr nz,VIDEO_CLEAR_LOOP		;jpenner - Loop until HL is zero

VDP_REG_SET:
 			ld e,80h					;jpenner - Set e to 80h	(Register 0)
	;jpenner - Register 0 (0x80) to #0			[xxxxxx00] Set mode selection bit M3 to zero and disable external video & horizontal interrupt
										; B0	0 - Not used
										; B1	0 - Not used
										; B2	0 - Not used
										; B3	0 - Not used
										; B4	0 - Not used
										; B5	0 - Not used
										; B6	0 - Clear		M3 - VDP option control for Sprites
										; B7	0 - Disable	Enable/Disable External VDP input
			ld a,00h					;jpenner - Set A to 00h [00000000]
			out (VIDEO_LATCH),a			;jpenner - Set Bit 6 & 7 to 0; mode selection M3, Disable external video and Horiz interupts
			ld a,e
			out (VIDEO_LATCH),a			;jpenner - Set register 0

	;jpenner - Register 1 (0x81) to #50		[01010r00] Select 40 column mode (Text Mode), enable screen and disable vertical interrupt
										; B0	0 - 4027 RAM option			4/16k Selection (4027 or 4108/4116)
										; B1	1 - Enable active display	Active display blank or enable active display
										; B2	0 - Disable VDP Interupt		Interupt Enable/Disable for VDP
										; B3	1 - M1 Text mode (with M3=0)	Mode bit 1
										; B4	0 - M2 Text mode (with M3=0)	Mode bit 2
										; B5	0 - Reserved
										; B6	0 - 8x8 Sprite					Sprite Size (8x8 or 16x16)
										; B7	0 - 1x Sprite magnification	Magnafacation (1x or 2x size)
			ld a,50h					;jpenner - Set A to 50h [01010000] Bit 1 & 3 set
			out (VIDEO_LATCH),a			;jpenner - Set 16k & Text mode
			inc e						;jpenner - Set e to 81h	(Register 1)
			ld a,e
			out (VIDEO_LATCH),a			;jpenner - Set register 1

    ;jpenner - Register 2 (0x82) to #0		[xxxx0000] Set Name table subblock (0000 * 0400h)
										; B0	0 - Not Used
										; B1	0 - Not Used
										; B2	0 - Not Used
										; B3	0 - Not Used
										; B4	0 - 8x = 0x8 + 0x4 + 0x2 + 0x1 = 0 * 0400h = 0000h
										; B5	0 - 4x = 0x8 + 0x4 + 0x2 + 0x1 = 0 * 0400h = 0000h
										; B6	0 - 2x = 0x8 + 0x4 + 0x2 + 0x1 = 0 * 0400h = 0000h
										; B7	0 - 1x = 0x8 + 0x4 + 0x2 + 0x1 = 0 * 0400h = 0000h
			xor a						;jpenner - Set A to 00h [00000000]
			out (VIDEO_LATCH),a			;jpenner - Set Base address of Name table sub-block (0000)
			inc e						;jpenner - Set e to 82h	(Register 2)
			ld a,e
			out (VIDEO_LATCH),a			;jpenner - Set register 2

    ;jpenner - Register 3 (0x83)				[00000000] ignored as 40 column mode does not need color table
										; B0	0 - Not Set
										; B1	0 - Not Set
										; B2	0 - Not Set
										; B3	0 - Not Set
										; B4	0 - Not Set
										; B5	0 - Not Set
										; B6	0 - Not Set
										; B7	0 - Not Set
			inc e						;jpenner - Set e to 83h	(Register 3)

    ;jpenner - Register 4 (0x84) to #1			[xxxxx000] Set pattern generator base address to 0800h (B1=1, 0001 * 0800h)
										; B0	0 - Not Used
										; B1	0 - Not Used
										; B2	0 - Not Used
										; B3	0 - Not Used
										; B4	0 - Not Used
										; B5	0 - x4 = 0x4 + 0x2 + 1x1 = 1 * 0800h = 0800h
										; B6	0 - x2 = 0x4 + 0x2 + 1x1 = 1 * 0800h = 0800h
										; B7	1 - x1 = 0x4 + 0x2 + 1x1 = 1 * 0800h = 0800h
			ld a, 01h					;jpenner - Set A to 01h [00000001]
			out (VIDEO_LATCH),a			;jpenner - Set Pattern Table base address (00000001)
			inc e						;jpenner - Set e to 84h	(Register 4)
			ld a,e
			out (VIDEO_LATCH),a			;jpenner - Set register 4

    ;jpenner - Register 5 (0x85)				[x0000000] ignored (5=Sprite attribute) as 40 column mode does not have sprites
										; B0	0 - Not Used
										; B1	0 - Not Set
										; B2	0 - Not Set
										; B3	0 - Not Set
										; B4	0 - Not Set
										; B5	0 - Not Set
										; B6	0 - Not Set
										; B7	0 - Not Set
			inc e						;jpenner - Set e to 80h	(Register 5)

    ;jpenner - Register 6 (0x86)				[xxxxx000] ignored (6=Sprite pattern) as 40 column mode does not have sprites
										; B0	0 - Not Used
										; B1	0 - Not Used
										; B2	0 - Not Used
										; B3	0 - Not Used
										; B4	0 - Not Used
										; B5	0 - Not Set
										; B6	0 - Not Set
										; B7	0 - Not Set
			inc e						;jpenner - Set e to 80h	(Register 6)

	;jpenner - Register 7 (0x87) for color		[00000000] Foreground & Background
										; B0	1 - Foreground = 1010 = A = Yellow Text
										; B1	0 - Foreground = 1010 = A = Yellow Text
										; B2	1 - Foreground = 1010 = A = Yellow Text
										; B3	0 - Foreground = 1010 = A = Yellow Text
										; B4	0 - Background = 0000 = 0 = Transparent Background
										; B5	0 - Background = 0000 = 0 = Transparent Background
										; B6	0 - Background = 0000 = 0 = Transparent Background
										; B7	0 - Background = 0000 = 0 = Transparent Background
										;jpenner - High nibble is Foreground, Low Nibble is Background
										;jpenner - Example A1h is Black background and Yellow Letters/Forground
										;jpenner		- 0 Transparent (I cannot say what this will represent)
										;jpenner		- 1 Black			2 Medium Green		3 Light Green
										;jpenner		- 4 Dark Blue		5 Light Blue		6 Dark Red
										;jpenner		- 7 Cyan			8 Medium Red		9 Light Red
										;jpenner		- A Dark Yellow	B Light Yellow		C Dark Green
										;jpenner 		- D Magenta		E Gray				F White
			ld a,0B0h					;jpenner - Yellow Letters/Forground and Black/Transparent/Background 
			out (VIDEO_LATCH),a			;jpenner - Set Foreground/background (10100000)
			inc e						;jpenner - Set e to 87h	(Register 7)
			ld a,e
			out (VIDEO_LATCH),a			;jpenner - Set register 7

ASCII_STORE:						    ;jpenner - Transfer ROM character Patterns to VRAM Pattern table @ 800h
			xor a						;jpenner - Set Low byte of VRAM Address; LSB
			out (VIDEO_LATCH),a			;jpenner - Push to VDP
			ld a,48h					;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx] + Pattern table address @ 0800h
			out (VIDEO_LATCH),a			;jpenner - Push to VDP
COPY_CHARS:								;jpenner - Copy character set to pattern table
			ld hl,NABU_CHARS			;jpenner - Point HL to Character set
			ld de,CHAR_MAP_SPACE		;jpenner - Set DE to byte count(Chars * 8, or (32+59nabu)*8 = 100h+1D8h
COPY_ASCII_LOOP:
			ld a,(hl)					;jpenner - Set a to the character byte
			out (VIDEO_DATA),a			;jpenner - Write the character byte
			inc hl						;jpenner - Point to next byte
			dec de						;jpenner - Point to next Address
			ld a,e						;jpenner - Set a to Low address byte
			or d						;jpenner - XOR a with High address byte (This is a zero check)
            nop							;jpenner - Supports a 4 clock cycle wait for VDP to catch up
            nop							;jpenner - Supports a 4 clock cycle wait for VDP to catch up
			jr nz,COPY_ASCII_LOOP		;jpenner - Loop through bytes until done
SET_VDP_TOP:							;jpenner - Set VDP write address to 4000h; top of Name Table
			xor a						;jpenner - Set Low byte of VRAM Address; LSB
			out (VIDEO_LATCH),a			;jpenner - Write/Push to VDP
			ld a,40h					;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
			out (VIDEO_LATCH),a			;jpenner - Write/Push to VDP
			ret							;jpenner - Return

CLEAR_SCREEN:
            xor a						;jpenner - Clear A register
            out (VIDEO_LATCH),a			;jpenner - Set lower address byte to VDP Address 0000 00h (4000h)
            ld a,40h					;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
            out (VIDEO_LATCH),a			;jpenner - Set Upper address byte to VDP Address 0100 40h (4000h)
            ld hl,03c0h					;jpenner - Set HL to 03C0h (number of positions in Text mode Name Table; 960)
CLEAR_LOOP:
            ld a,20h					;jpenner - Set A to a space " "
            out (VIDEO_DATA),a			;jpenner - Put Space in the VDP table position
            dec hl						;jpenner - point to next VDP table position
            ld a,l						;jpenner - Set A with Low byte
            or h						;jpenner - Compare to High byte
            jr nz,CLEAR_LOOP			;jpenner - Loop until Zero
CLEAR_HOME:								;jpenner - Reposition address to top of VDP
            xor a						;jpenner - Clear A register
            out (VIDEO_LATCH),a			;jpenner - Set lower address byte to VDP Address 0000 00h (4000h)
            ld a,40h					;jpenner - Set high order bit for writing to VRAM of the MSB [x1xxxxxx]
            out (VIDEO_LATCH),a			;jpenner - Set Upper address byte to VDP Address 0100 40h (4000h)
            xor a						;jpenner - Clear A register; Set to 00h
 			ld (POS_X),a				;jpenner - Set x/Column position on Text Display (Home)
			ld (POS_Y),a				;jpenner - Set y/Row position on Text Display (Home)
            ret

KEYBD_INIT:
            xor a						;jpenner - Clear A register
			call KEYBD_SEND				;jpenner - Debounce/ATTN/Signal clear
			call KEYBD_SEND				;jpenner - Debounce/ATTN/Signal clear
			call KEYBD_SEND				;jpenner - Debounce/ATTN/Signal clear
			call KEYBD_SEND				;jpenner - Debounce/ATTN/Signal clear
			call KEYBD_SEND				;jpenner - Debounce/ATTN/Signal clear
			ld a,040h			   	 	;jpenner - Set A to 01000000; UART reset command
			call KEYBD_SEND				;jpenner - Send UART Reset
			ld a,04eh				   	;jpenner - Set A to 01001110  Mode Word
										;jpenner - - 01=1 stop bits
										;jpenner - - 00=No parity
										;jpenner - - 11=8bits
										;jpenner - - 10=16x baud rate
			call KEYBD_SEND				;jpenner - Send mode word (UART Base Protocol)
			ld a,004h				   	;jpenner - Set A to 00000100  Command Word
										;jpenner - - 0=Hunt mode
										;jpenner - - 0=Return to Mode word
										;jpenner - - 0=RST output Zero
										;jpenner - - 0=Reset all Error flags
										;jpenner - - 0=Not normal operations
										;jpenner - - 1=Receive Enable
										;jpenner - - 0=DTR will output "1"
										;jpenner - - 0=Transmit enabled
			call KEYBD_SEND				;jpenner - Send Command word (UART Other Protocol settings)
			ret

KEYBD_SEND:
			out (KEYBD_STATUS),a		;jpenner - Set Keyboard function (mode/command)
            nop							;jpenner - Supports a 4 clock cycle wait as a signaling delay
            nop							;jpenner - Supports a 4 clock cycle wait as a signaling delay
            nop							;jpenner - Supports a 4 clock cycle wait as a signaling delay
            nop							;jpenner - Supports a 4 clock cycle wait as a signaling delay
            nop							;jpenner - Supports a 4 clock cycle wait as a signaling delay
			ret

SOUND_INIT:								;jpenner - Registers in documentation R10-R17 are R8-R15
            ld a,08h					;jpenner - R8 - Channel A Amplitude
            out (SOUND_LATCH),a			;jpenner - R8 - Point to Register 8
            ld a,0fh					;jpenner - R8 - Set to 0000 1111 (Mode 0-fixed, High/Loud)
            out (SOUND_DATA),a			;jpenner - R8 - Set register settings
            ld a,00h					;jpenner - R0 - Channel A Tone Period: 8bit Fine Tune
            out (SOUND_LATCH),a			;jpenner - R0 - Point to Register 0
            ld a,04fh					;jpenner - R0 - Set to 0100 1111 (Fine Tune is 22.07 Hz or F)
            out (SOUND_DATA),a			;jpenner - R0 - Set register settings
            ld a,01h					;jpenner - R1 - Channel A Tone Period: 4bit Coarse Tune
            out (SOUND_LATCH),a			;jpenner - R1 - Point to Register 1
            ld a,00h					;jpenner - R1 - Set to 0000 (Coarse Tune is 0)
            out (SOUND_DATA),a			;jpenner - R1 - Set register settings
            ld a,07h					;jpenner - R7 - Mixer control & I/O Enable
            out (SOUND_LATCH),a			;jpenner - R7 - Point to Register 7
            ld a,03fh					;jpenner - R7 - Set to 0011 1111 (All Noise & Tone Channels Disabled)
            out (SOUND_DATA),a			;jpenner - R7 - Set register settings
            ret
SOUND_INIT_END:

SOUND_INIT2:					;jpenner - NOT USED HERE - Straight copy from the NABU ROM (Initialization for Channel A - Tone)
;			ld   a,07h					;jpenner - R7 - Mixer control - I/O Enable
;			out  (SOUND_LATCH),a		;jpenner - R7 - Point to Register 7
;			ld   a,7Eh 				;jpenner - R7 - Set to 0111 1110 (All Noise & Tone Channels B,C Disabled)
;			out  (SOUND_DATA),a		;jpenner - R7 - Set register settings
;			ld   a,08h					;jpenner - R8 - Channel A Amplitude
;			out  (SOUND_LATCH),a		;jpenner - R8 - Point to Register 8
;			ld   a,06h					;jpenner - R8 - Set to 0000 0110 (Mode 0-fixed, Medium/Low)
;			out  (SOUND_DATA),a		;jpenner - R8 - Set register settings
;			ld   a,01h					;jpenner - R1 - Channel A Tone Period (Coarse)
;			out  (SOUND_LATCH),a		;jpenner - R1 - Point to Register 1
;			dec  a						;jpenner - R0 - Set to xxxx 0000 (Channel A Tone Disabled)
;			out  (SOUND_DATA),a		;jpenner - R0 - Set register settings
;			ret         
SOUND_INIT2_END:

DELAY:      							;jpenner - Delay using HL for cycle count		T-States 31 + (26*HL) - 5
			push af						;jpenner - Save AF								11
DELAY_LOOP:
            dec hl						;jpenner - Drop count								6*HL
            ld a,l						;jpenner - Get L									4*HL
            or h						;jpenner - OR L with H to check for 0			4*HL
            jr nz,DELAY_LOOP			;jpenner - Loop if Zero not reached				12*HL (7 at end)
            pop af						;jpenner - Restore AF								10
            ret							;jpenner - Return									10
;----------------------------------------------------------------------------------------------------
;--- Data -------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------------

TITLE:		.db "NABU SYSTEM BIOS-MONITOR VER 3.0",04h
            .db "JAMES PENNER 02/23/2023",04h,04h
			.db "READY",04h
TITLE_END:

HELP_MSG:
			.db "?-HELP       A-ADDR RAM   D-DUMP RAM",04h
			.db "L-LOAD       S-SAVE       C-COPY RAM",04h
			.db "R-REGISTERS  B-BOOT/RESET G-GO!",04h
			.db "P-PANEL CHK",04h,04h
HELP_MSG_END:

REG1_MSG:	.db "REGISTERS",04h
			.db "A F   B C   D E   H L   I X   I Y",04h
REG1_MSG_END:
REG2_MSG:	.db "STATUS (F)  S  Z  -  H  -  P  N  C",04h
REG2_MSG_END:
REG3_MSG:	.db "CONTROL REG R2 R1 LP LA LC RF PS RE",04h
REG3_MSG_END:
PANL_MSG:	.db	"PRESS 1,2,3 OR <ESC>",04h,04h
PANL_MSG_END:

ERR01:		.db 04h,"CMD?",04h
ERR01_END:
ERR02:		.db 04h,"HEX?",04h
ERR02_END:

ADDR_PMT:	.db "ADDR?",00h						;jpenner - Address display and Edit
ADDR_PMT_END:
SORC_ADR:	.db "SOURCE?",00h					;jpenner - Address display and Edit
SORC_ADR_END:
DEST_ADR:	.db "DESTIN?",00h					;jpenner - Address display and Edit
DEST_ADR_END:
BYTE_CNT:	.db "BYTES?",00h					;jpenner - Address display and Edit
BYTE_CNT_END:
LOAD_PMT:	.db "SOURCE? (F/S) ",00h			;jpenner - Load Serial, SD, other to RAM
LOAD_PMT_END:
WRIT_PMT:	.db "DESTIN? (F/S) ",00h			;jpenner - Write RAM to Serial, SD, Other
WRIT_PMT_END:

HEX_DIGIT:
			.db "FEDCBA9876543210"
HEX_DIGIT_END:

ROW_OFFSET_ARRAY:						;jpenner - Array of 24 row starting addresses in VRAM.
            .dw 0000h, 0028h, 0050h, 0078h, 00a0h, 00c8h, 00f0h, 0118h
            .dw 0140h, 0168h, 0190h, 01b8h, 01e0h, 0208h, 0230h, 0258h
            .dw 0280h, 02a8h, 02d0h, 02f8h, 0320h, 0348h, 0370h, 0398h


NABU_CHARS:								;jpenner - NABU Character set as extracted from original ROM (First 32 are fillers)
    ; ASCII(00h), NUL
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %10101010    ;AA

    ; ASCII(01h), SOH
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00000000    ;00
    .db %00010000    ;10
    .db %10101010    ;AA

    ; ASCII(02h), STX
    .db %00101000    ;28
    .db %00101000    ;28
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %10101010    ;AA

    ; ASCII(03h), ETX
    .db %00101000    ;28
    .db %00101000    ;28
    .db %01111100    ;7C
    .db %00101000    ;28
    .db %01111100    ;7C
    .db %00101000    ;28
    .db %00101000    ;28
    .db %10101010    ;AA

    ; ASCII(04h), EOT
    .db %00111000    ;38
    .db %01010100    ;54
    .db %01010000    ;50
    .db %00111000    ;38
    .db %00010100    ;14
    .db %01010100    ;54
    .db %00111000    ;38
    .db %10101010    ;AA

    ; ASCII(05h), ENQ
    .db %01100000    ;60
    .db %01100100    ;64
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01101100    ;6C
    .db %00001100    ;0C
    .db %10101010    ;AA

    ; ASCII(06h), ACK
    .db %00010000    ;10
    .db %00101000    ;28
    .db %00101000    ;28
    .db %00110000    ;30
    .db %01010000    ;50
    .db %01001100    ;4C
    .db %01111100    ;7C
    .db %10101010    ;AA

    ; ASCII(07h), BEL
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00010000    ;10
    .db %01100000    ;60
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %10101010    ;AA

    ; ASCII(08h), BS
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %10101010    ;AA

    ; ASCII(09h), HT
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %10101010    ;AA

    ; ASCII(0Ah), LF
    .db %00000000    ;00
    .db %01010100    ;54
    .db %00111000    ;38
    .db %01111100    ;7C
    .db %00111000    ;38
    .db %01010100    ;54
    .db %00010000    ;10
    .db %10101010    ;AA

    ; ASCII(0Bh), VT
    .db %00000000    ;00
	.db %00000000    ;00
    .db %00010000    ;10
    .db %00010000    ;10
    .db %01111100    ;7C
    .db %00010000    ;10
    .db %00010000    ;10
    .db %10101010    ;AA

    ; ASCII(0Ch), FF
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00010000    ;10
    .db %10101010    ;AA

    ; ASCII(0Dh), CR
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00111000    ;38
    .db %00000000    ;00
    .db %00000000    ;00
    .db %10101010    ;AA

	; ASCII(0Eh), SO
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00011000    ;18
    .db %00011000    ;18
    .db %10101010    ;AA

    ; ASCII(0Fh), SI
    .db %00000100    ;04
    .db %00000100    ;04
    .db %00001000    ;08
    .db %00011000    ;18
    .db %00110000    ;30
    .db %00100000    ;20
    .db %01000000    ;40
    .db %10101010    ;AA

    ; ASCII(10h), DEL
    .db %00111000    ;38
    .db %01000100    ;44
    .db %01001100    ;4C
    .db %01010100    ;54
    .db %01100100    ;64
    .db %01000100    ;44
    .db %00111000    ;38
    .db %10101010    ;AA

    ; ASCII(11h), DC1
    .db %00010000    ;10
    .db %00110000    ;30
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00111000    ;38
    .db %10101010    ;AA

    ; ASCII(12h), DC2
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00011000    ;18
    .db %00110000    ;30
    .db %00100000    ;20
    .db %01111000    ;78
    .db %10101010    ;AA

    ; ASCII(13h), DC3
    .db %00110000    ;30
    .db %01001000    ;48
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00001000    ;08
    .db %01001000    ;48
    .db %00110000    ;30
    .db %10101010    ;AA

    ; ASCII(14h), DC4
    .db %00010000    ;10
    .db %00110000    ;30
    .db %00110000    ;30
    .db %01010000    ;50
    .db %01010000    ;50
    .db %01111000    ;78
    .db %00010000    ;10
    .db %10101010    ;AA

    ; ASCII(15h), NAK
    .db %01111000    ;78
    .db %01000000    ;40
    .db %01010000    ;50
    .db %01101000    ;68
    .db %00001000    ;08
    .db %01001000    ;48
    .db %00110000    ;30
    .db %10101010    ;AA

    ; ASCII(16h), SYN
    .db %00110000    ;30
    .db %00101000    ;28
    .db %01000000    ;40
    .db %01110000    ;70
    .db %01101000    ;68
    .db %01001000    ;48
    .db %00110000    ;30
    .db %10101010    ;AA

    ; ASCII(17h), ETB
    .db %01111000    ;78
    .db %01001000    ;48
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00110000    ;30
    .db %00100000    ;20
    .db %00100000    ;20
    .db %10101010    ;AA

    ; ASCII(18h), CAN
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00110000    ;30
    .db %10101010    ;AA

    ; ASCII(19h), EM
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00111000    ;38
    .db %00001000    ;08
    .db %01010000    ;50
    .db %00110000    ;30
    .db %10101010    ;AA

    ; ASCII(1Ah), SUB
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %10101010    ;AA

    ; ASCII(1Bh), ESC
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00010000    ;10
    .db %10101010    ;AA

    ; ASCII(1Ch), FS
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %00001000    ;08
    .db %10101010    ;AA

    ; ASCII(1Dh), GS
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %01111000    ;78
    .db %00000000    ;00
    .db %01111000    ;78
    .db %00000000    ;00
    .db %10101010    ;AA

    ; ASCII(1Eh), RS
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %10101010    ;AA

    ; ASCII(1Fh), US
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00010000    ;10
    .db %00100000    ;20
    .db %00100000    ;20
    .db %00000000    ;00
    .db %10101010    ;AA

    ; ASCII(20h), " " (space)
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00

    ; ASCII(21h), "!"
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00000000    ;00
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(22h), """
    .db %00101000    ;28
    .db %00101000    ;28
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00

    ; ASCII(23h), "#"
    .db %00101000    ;28
    .db %00101000    ;28
    .db %01111100    ;7C
    .db %00101000    ;28
    .db %01111100    ;7C
    .db %00101000    ;28
    .db %00101000    ;28
    .db %00000000    ;00

    ; ASCII(24h), "$"
    .db %00111000    ;38
    .db %01010100    ;54
    .db %01010000    ;50
    .db %00111000    ;38
    .db %00010100    ;14
    .db %01010100    ;54
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(25h), "%"
    .db %01100000    ;60
    .db %01100100    ;64
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01101100    ;6C
    .db %00001100    ;0C
    .db %00000000    ;00

    ; ASCII(26h), "&"
    .db %00010000    ;10
    .db %00101000    ;28
    .db %00101000    ;28
    .db %00110000    ;30
    .db %01010000    ;50
    .db %01001100    ;4C
    .db %01111100    ;7C
    .db %00000000    ;00

    ; ASCII(27h), "'"
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00010000    ;10
    .db %01100000    ;60
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00

    ; ASCII(28h), "("
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(29h), ")"
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %00000000    ;00

    ; ASCII(2Ah), "*"
    .db %00000000    ;00
    .db %01010100    ;54
    .db %00111000    ;38
    .db %01111100    ;7C
    .db %00111000    ;38
    .db %01010100    ;54
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(2Bh), "+"
    .db %00000000    ;00
	.db %00000000    ;00
    .db %00010000    ;10
    .db %00010000    ;10
    .db %01111100    ;7C
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(2Ch), ","
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00010000    ;10
    .db %01100000    ;60

    ; ASCII(2Dh), "-"
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00111000    ;38
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00

	; ASCII(2Eh), "."
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00011000    ;18
    .db %00011000    ;18
    .db %00000000    ;00

    ; ASCII(2Fh), "/"
    .db %00000100    ;04
    .db %00000100    ;04
    .db %00001000    ;08
    .db %00011000    ;18
    .db %00110000    ;30
    .db %00100000    ;20
    .db %01000000    ;40
    .db %00000000    ;00

    ; ASCII(30h), "0"
    .db %00111000    ;38
    .db %01000100    ;44
    .db %01001100    ;4C
    .db %01010100    ;54
    .db %01100100    ;64
    .db %01000100    ;44
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(31h), "1"
    .db %00010000    ;10
    .db %00110000    ;30
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(32h), "2"
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00011000    ;18
    .db %00110000    ;30
    .db %00100000    ;20
    .db %01111000    ;78
    .db %00000000    ;00

    ; ASCII(33h), "3"
    .db %00110000    ;30
    .db %01001000    ;48
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00001000    ;08
    .db %01001000    ;48
    .db %00110000    ;30
    .db %00000000    ;00

    ; ASCII(34h), "4"
    .db %00010000    ;10
    .db %00110000    ;30
    .db %00110000    ;30
    .db %01010000    ;50
    .db %01010000    ;50
    .db %01111000    ;78
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(35h), "5"
    .db %01111000    ;78
    .db %01000000    ;40
    .db %01010000    ;50
    .db %01101000    ;68
    .db %00001000    ;08
    .db %01001000    ;48
    .db %00110000    ;30
    .db %00000000    ;00

    ; ASCII(36h), "6"
    .db %00110000    ;30
    .db %00101000    ;28
    .db %01000000    ;40
    .db %01110000    ;70
    .db %01101000    ;68
    .db %01001000    ;48
    .db %00110000    ;30
    .db %00000000    ;00

    ; ASCII(37h), "7"
    .db %01111000    ;78
    .db %01001000    ;48
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00110000    ;30
    .db %00100000    ;20
    .db %00100000    ;20
    .db %00000000    ;00

    ; ASCII(38h), "8"
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00110000    ;30
    .db %00000000    ;00

    ; ASCII(39h), "9"
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00111000    ;38
    .db %00001000    ;08
    .db %01010000    ;50
    .db %00110000    ;30
    .db %00000000    ;00

    ; ASCII(3Ah), ":"
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00000000    ;00

    ; ASCII(3Bh), ";"
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00110000    ;30
    .db %00000000    ;00
    .db %00110000    ;30
    .db %00010000    ;10
    .db %01000000    ;40

    ; ASCII(3Ch), "<"
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %00001000    ;08
    .db %00000000    ;00

    ; ASCII(3Dh), "="
    .db %00000000    ;00
    .db %00000000    ;00
    .db %00000000    ;00
    .db %01111000    ;78
    .db %00000000    ;00
    .db %01111000    ;78
    .db %00000000    ;00
    .db %00000000    ;00

    ; ASCII(3Eh), ">"
    .db %01000000    ;40
    .db %00100000    ;20
    .db %00010000    ;10
    .db %00001000    ;08
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01000000    ;40
    .db %00000000    ;00

    ; ASCII(3Fh), "?"
    .db %00110000    ;30
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00010000    ;10
    .db %00100000    ;20
    .db %00100000    ;20
    .db %00000000    ;00
    .db %00100000    ;20

    ; ASCII(40h), "@"
    .db %01000000    ;40
    .db %00111000    ;38
    .db %00000100    ;04
    .db %00111000    ;38
    .db %00001000    ;08
    .db %00111000    ;38
    .db %01001000    ;48
    .db %00110100    ;34

    ; ASCII(41h), "A"
    .db %00010000    ;10
    .db %00101000    ;28
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01111100    ;7C
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00000000    ;00

    ; ASCII(42h), "B"
    .db %01111000    ;78
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01111000    ;78
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01111000    ;78
    .db %00000000    ;00

    ; ASCII(43h), "C"
    .db %00111000    ;38
    .db %01000100    ;44
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000100    ;44
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(44h), "D"
    .db %01110000    ;70
    .db %01001000    ;48
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01001000    ;48
    .db %01110000    ;70
    .db %00000000    ;00

    ; ASCII(45h), "E"
    .db %01111100    ;7C
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01110000    ;70
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01111100    ;7C
    .db %00000000    ;00

    ; ASCII(46h), "F"
    .db %01111100    ;7C
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01110000    ;70
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %00000000    ;00

    ; ASCII(47h), "G"
    .db %00111000    ;38
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000000    ;40
    .db %01011100    ;5C
    .db %01000100    ;44
    .db %00111100    ;3C
    .db %00000000    ;00

    ; ASCII(48h), "H"
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01111100    ;7C
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00000000    ;00

    ; ASCII(49h), "I"
    .db %00111000    ;38
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(4Ah), "J"
    .db %00011100    ;1C
    .db %00001000    ;08
    .db %00001000    ;08
    .db %00001000    ;08
    .db %01001000    ;48
    .db %01001000    ;48
    .db %00110000    ;30
    .db %00000000    ;00

    ; ASCII(4Bh), "K"
    .db %01001000    ;48
    .db %01001000    ;48
    .db %01010000    ;50
    .db %01110000    ;70
    .db %01010000    ;50
    .db %01001000    ;48
    .db %01001100    ;4C
    .db %00000000    ;00

    ; ASCII(4Ch), "L"
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01111100    ;7C
    .db %00000000    ;00

    ; ASCII(4Dh), "M"
    .db %01101100    ;6C
    .db %01010100    ;54
    .db %01010100    ;54
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00000000    ;00

    ; ASCII(4Eh), "N"
    .db %01000100    ;44
    .db %01100100    ;64
    .db %01100100    ;64
    .db %01010100    ;54
    .db %01010100    ;54
    .db %01001100    ;4C
    .db %01001100    ;4C
    .db %00000000    ;00

    ; ASCII(4Fh), "O"
    .db %00111000    ;38
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(50h), "P"
    .db %01111000    ;78
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01111000    ;78
    .db %01000000    ;40
    .db %01000000    ;40
    .db %01000000    ;40
    .db %00000000    ;00

    ; ASCII(51h), "Q"
    .db %00111000    ;38
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01010100    ;54
    .db %01001000    ;48
    .db %00110100    ;34
    .db %00000000    ;00

    ; ASCII(52h), "R"
    .db %01111000    ;78
    .db %01001000    ;48
    .db %01001000    ;48
    .db %01111000    ;78
    .db %01010000    ;50
    .db %01001000    ;48
    .db %01001100    ;4C
    .db %00000000    ;00

    ; ASCII(53h), "S"
    .db %00111000    ;38
    .db %01000100    ;44
    .db %01000000    ;40
    .db %00111000    ;38
    .db %00000100    ;04
    .db %01000100    ;44
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(54h), "T"
    .db %01111100    ;7C
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(55h), "U"
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00111000    ;38
    .db %00000000    ;00

    ; ASCII(56h), "V"
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00101000    ;28
    .db %00101000    ;28
    .db %00101000    ;28
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(57h), "W"
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01010100    ;54
    .db %01010100    ;54
    .db %00101000    ;28
    .db %00000000    ;00

    ; ASCII(58h), "X"
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00101000    ;28
    .db %00010000    ;10
    .db %00101000    ;28
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00000000    ;00

    ; ASCII(59h), "Y"
    .db %01000100    ;44
    .db %01000100    ;44
    .db %01000100    ;44
    .db %00111000    ;38
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00010000    ;10
    .db %00000000    ;00

    ; ASCII(5Ah), "Z"
    .db %01111100    ;7C
    .db %00001100    ;0C
    .db %00011000    ;18
    .db %00010000    ;10
    .db %00100000    ;20
    .db %01100000    ;60
    .db %01111100    ;7C
    .db %00000000    ;00

NABU_CHARS_END:
.end

